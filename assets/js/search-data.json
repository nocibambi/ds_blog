{
  
    
        "post0": {
            "title": "Test notebook",
            "content": "import altair as alt alt.renderers . RendererRegistry(active=&#39;default&#39;, registered=[&#39;colab&#39;, &#39;default&#39;, &#39;json&#39;, &#39;jupyterlab&#39;, &#39;kaggle&#39;, &#39;nteract&#39;, &#39;png&#39;, &#39;svg&#39;, &#39;zeppelin&#39;]) . from vega_datasets import data . health_income = data(&#39;gapminder-health-income&#39;) health_income.head() . country income health population . 0 Afghanistan | 1925 | 57.63 | 32526562 | . 1 Albania | 10620 | 76.00 | 2896679 | . 2 Algeria | 13434 | 76.50 | 39666519 | . 3 Andorra | 46577 | 84.10 | 70473 | . 4 Angola | 7615 | 61.00 | 25021974 | . income_domain = [health_income[&#39;income&#39;].min(), health_income[&#39;income&#39;].max()] health_domain = [health_income[&#39;health&#39;].min(), health_income[&#39;health&#39;].max()] alt.Chart(health_income).mark_point().encode( alt.X(&#39;income:Q&#39;, scale=alt.Scale(domain=income_domain)), alt.Y(&#39;health:Q&#39;, scale=alt.Scale(domain=health_domain)), alt.Size(&#39;population:Q&#39;), alt.Tooltip(&#39;country:N&#39;) ).properties(height=600, width=800) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html .",
            "url": "andrasnovoszath.com/2020/09/21/test.html",
            "relUrl": "/2020/09/21/test.html",
            "date": " • Sep 21, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Data scale normalization",
            "content": "Normalization is a common technique used in machine learning to render the scales of different magnitudes to a common range between 0 and 1. . Here we demonstrate how this is done with pandas and altair. . Original inspiration: (Jason Brownlee: Machine Learning Algorithms from Scratch)[https://machinelearningmastery.com/machine-learning-algorithms-from-scratch/] . import altair as alt # alt.renderers.enable(&#39;default&#39;) alt.renderers . RendererRegistry(active=&#39;default&#39;, registered=[&#39;colab&#39;, &#39;default&#39;, &#39;json&#39;, &#39;jupyterlab&#39;, &#39;kaggle&#39;, &#39;nteract&#39;, &#39;png&#39;, &#39;svg&#39;, &#39;zeppelin&#39;]) . from vega_datasets import data . We use the Gapminder health and income dataset . health_income = data(&#39;gapminder-health-income&#39;) health_income.head() . country income health population . 0 Afghanistan | 1925 | 57.63 | 32526562 | . 1 Albania | 10620 | 76.00 | 2896679 | . 2 Algeria | 13434 | 76.50 | 39666519 | . 3 Andorra | 46577 | 84.10 | 70473 | . 4 Angola | 7615 | 61.00 | 25021974 | . income_domain = [health_income[&#39;income&#39;].min(), health_income[&#39;income&#39;].max()] health_domain = [health_income[&#39;health&#39;].min(), health_income[&#39;health&#39;].max()] alt.Chart(health_income).mark_point().encode( alt.X(&#39;income:Q&#39;, scale=alt.Scale(domain=income_domain)), alt.Y(&#39;health:Q&#39;, scale=alt.Scale(domain=health_domain)), alt.Size(&#39;population:Q&#39;), alt.Tooltip(&#39;country:N&#39;) ).properties(height=600, width=800) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . The process: . Take the values&#39; difference from the smallest one; | Take the value range, that is, the difference between the largest and smallest values; | Divide the reduced values with the range. | $ text {scaled value} = frac{value - min} {max - min} $ . The first step ensures that the smallest value will become 0. Dividing the reduced values by the range &#39;compresses&#39; the values so the new maximum becomes 1. . quantitative_columns = [&#39;income&#39;, &#39;health&#39;, &#39;population&#39;] . The original minimum and maximum values . health_income.loc[health_income[quantitative_columns].idxmin(), :] . country income health population . 32 Central African Republic | 599 | 53.8 | 4900274 | . 93 Lesotho | 2598 | 48.5 | 2135022 | . 105 Marshall Islands | 3661 | 65.1 | 52993 | . minimums = health_income[quantitative_columns].min() minimums . income 599.0 health 48.5 population 52993.0 dtype: float64 . health_income.loc[health_income[quantitative_columns].idxmax(), :] . country income health population . 134 Qatar | 132877 | 82.0 | 2235355 | . 3 Andorra | 46577 | 84.1 | 70473 | . 35 China | 13334 | 76.9 | 1376048943 | . maximums = health_income[quantitative_columns].max() maximums . income 1.328770e+05 health 8.410000e+01 population 1.376049e+09 dtype: float64 . Difference of values from the column minimum . health_income[quantitative_columns] - minimums . income health population . 0 1326.0 | 9.13 | 32473569.0 | . 1 10021.0 | 27.50 | 2843686.0 | . 2 12835.0 | 28.00 | 39613526.0 | . 3 45978.0 | 35.60 | 17480.0 | . 4 7016.0 | 12.50 | 24968981.0 | . ... ... | ... | ... | . 182 5024.0 | 28.00 | 93394608.0 | . 183 3720.0 | 26.70 | 4615473.0 | . 184 3288.0 | 19.10 | 26779222.0 | . 185 3435.0 | 10.46 | 16158774.0 | . 186 1202.0 | 11.51 | 15549758.0 | . 187 rows × 3 columns . Value ranges: the difference between the maximum and the minimum . maximums - minimums . income 1.322780e+05 health 3.560000e+01 population 1.375996e+09 dtype: float64 . Let&#39;s normalize the dataset . def normalize_dataset(dataset, quantitative_columns): dataset = dataset.copy() minimums = dataset[quantitative_columns].min() maximums = dataset[quantitative_columns].max() dataset[quantitative_columns] = (dataset[quantitative_columns] - minimums) / (maximums - minimums) return dataset . normalized_health_income = normalize_dataset(health_income, quantitative_columns) normalized_health_income . country income health population . 0 Afghanistan | 0.010024 | 0.256461 | 0.023600 | . 1 Albania | 0.075757 | 0.772472 | 0.002067 | . 2 Algeria | 0.097030 | 0.786517 | 0.028789 | . 3 Andorra | 0.347586 | 1.000000 | 0.000013 | . 4 Angola | 0.053040 | 0.351124 | 0.018146 | . ... ... | ... | ... | ... | . 182 Vietnam | 0.037981 | 0.786517 | 0.067874 | . 183 West Bank and Gaza | 0.028123 | 0.750000 | 0.003354 | . 184 Yemen | 0.024857 | 0.536517 | 0.019462 | . 185 Zambia | 0.025968 | 0.293820 | 0.011743 | . 186 Zimbabwe | 0.009087 | 0.323315 | 0.011301 | . 187 rows × 4 columns . The new minimum and maximum values . normalized_health_income.loc[normalized_health_income[quantitative_columns].idxmin(), :] . country income health population . 32 Central African Republic | 0.000000 | 0.148876 | 0.003523 | . 93 Lesotho | 0.015112 | 0.000000 | 0.001513 | . 105 Marshall Islands | 0.023148 | 0.466292 | 0.000000 | . normalized_health_income.loc[normalized_health_income[quantitative_columns].idxmax(), :] . country income health population . 134 Qatar | 1.000000 | 0.941011 | 0.001586 | . 3 Andorra | 0.347586 | 1.000000 | 0.000013 | . 35 China | 0.096275 | 0.797753 | 1.000000 | . Plotting the normalized data, we got the same results, but with the income, health, and population scales all normalized to the [0, 1] range. . Maximum values . alt.Chart(normalized_health_income).mark_point().encode( alt.X(&#39;income:Q&#39;,), alt.Y(&#39;health:Q&#39;), alt.Size(&#39;population:Q&#39;), alt.Tooltip(&#39;country:N&#39;) ).properties(height=600, width=800) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html .",
            "url": "andrasnovoszath.com/2020/09/21/normalize-scale.html",
            "relUrl": "/2020/09/21/normalize-scale.html",
            "date": " • Sep 21, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "How to use Altair for data visualization in Python?",
            "content": "For the notebook I use the following packages. . 3.8.5 (default, Sep 4 2020, 07:30:14) [GCC 7.3.0] pandas: 1.1.0 altair: 3.2.0 . We load the &#39;flights&#39; example dataset . # collapse_show flights = &quot;https://vega.github.io/vega-datasets/data/flights-5k.json&quot; . . df_flights = pd.read_json(flights) origins = df_flights[&quot;origin&quot;].unique().tolist() destinations = df_flights[&quot;destination&quot;].unique().tolist() . # Origin locations print(&quot; t&quot;.join(origins)) . SAT SNA SJC SMF OKC PHX BHM MDW TUL MSY LAS BUF DTW HRL MCO RNO OAK JAX MCI SAN BNA STL FLL TPA HOU LAX BWI AUS ELP ONT PBI ABQ IND PDX DAL CLE MHT AMA SLC PVD SEA BOI ISP OMA LBB CRP RDU SDF BUR MAF LIT TUS BDL GEG SFO JAN IAH ALB CMH . # Destination locations print(&quot; t&quot;.join(destinations)) . HOU OAK SAN PHX RNO STL SDF OMA DAL SJC BWI MDW FLL SEA BHM PDX SLC BNA BOI TUS LAX ONT MCI CMH BDL LAS ISP TPA ABQ SAT MAF TUL ELP MCO SMF MHT MSY AUS PVD GEG BUR CRP JAN LIT SFO SNA OKC CLE IND HRL BUF JAX RDU AMA DTW PBI LBB ALB IAH . # Altair single-value selection selection = alt.selection_single( name=&quot;Select&quot;, fields=[&quot;origin&quot;, &quot;destination&quot;], bind={ &quot;origin&quot;: alt.binding_select(options=origins), &quot;destination&quot;: alt.binding_select(options=destinations), }, ) . # Scatter plot alt.Chart(df_flights).mark_circle().add_selection( selection ).encode( x=&#39;distance&#39;, y=&#39;delay&#39;, tooltip=&#39;date&#39;, opacity=alt.condition(selection, alt.value(.75), alt.value(.05)) ) # alt.Chart(movies).mark_circle().add_selection( # selection # ).encode( # x=&#39;Rotten Tomatoes Rating:Q&#39;, # y=&#39;IMDB Rating:Q&#39;, # tooltip=&#39;Title:N&#39;, # opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) # ) . NameError Traceback (most recent call last) &lt;ipython-input-2-54fe3fca6fea&gt; in &lt;module&gt; 1 # Scatter plot 2 -&gt; 3 alt.Chart(df_flights).mark_circle().add_selection( 4 selection 5 ).encode( NameError: name &#39;alt&#39; is not defined . Altair tutorial introduction . from vega_datasets import data . # hide_collapse # load more datasets population = data.population() jobs = data.jobs() countries = data.countries() budget = data.budget() unemployment_industries = data.unemployment_across_industries() employment = data.us_employment() . employment = employment.set_index(&#39;month&#39;).stack().reset_index().rename(columns={&#39;level_1&#39;: &#39;sector&#39;, 0: &#39;employment&#39;}) employment = employment[employment[&#39;sector&#39;] != &#39;nonfarm_change&#39;] . employment . month sector employment . 0 2006-01-01 | nonfarm | 135450.0 | . 1 2006-01-01 | private | 113603.0 | . 2 2006-01-01 | goods_producing | 22467.0 | . 3 2006-01-01 | service_providing | 112983.0 | . 4 2006-01-01 | private_service_providing | 91136.0 | . ... ... | ... | ... | . 2754 2015-12-01 | professional_and_business_services | 19892.0 | . 2755 2015-12-01 | education_and_health_services | 22318.0 | . 2756 2015-12-01 | leisure_and_hospitality | 15408.0 | . 2757 2015-12-01 | other_services | 5652.0 | . 2758 2015-12-01 | government | 22100.0 | . 2640 rows × 3 columns . employment.groupby(&#39;sector&#39;).mean().sort_values(&#39;employment&#39;) . employment . sector . utilities 553.744167 | . mining_and_logging 777.400000 | . information 2809.400000 | . transportation_and_warehousing 4469.073333 | . nondurable_goods 4667.816667 | . other_services 5460.333333 | . wholesale_trade 5751.100000 | . construction 6365.475000 | . durable_goods 7832.866667 | . financial_activities 7991.691667 | . manufacturing 12500.683333 | . leisure_and_hospitality 13731.416667 | . retail_trade 15066.603333 | . professional_and_business_services 17902.258333 | . goods_producing 19643.558333 | . education_and_health_services 20129.216667 | . government 22150.125000 | . trade_transportation_utilties 25840.566667 | . private_service_providing 93864.883333 | . private 113508.441667 | . service_providing 116015.008333 | . nonfarm 135658.566667 | .",
            "url": "andrasnovoszath.com/2020/09/21/my_altair_tutorial.html",
            "relUrl": "/2020/09/21/my_altair_tutorial.html",
            "date": " • Sep 21, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "Interaction",
            "content": "import pandas as pd import altair as alt . Datasets . We will visualize a variety of datasets from the vega-datasets collection: . A dataset of cars from the 1970s and early 1980s, | A dataset of movies, previously used in the Data Transformation notebook, | A dataset containing ten years of S&amp;P 500 (sp500) stock prices, | A dataset of technology company stocks, and | A dataset of flights, including departure time, distance, and arrival delay. | . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . Introducing Selections . Let&#39;s start with a basic selection: simply clicking a point to highlight it. Using the cars dataset, we&#39;ll start with a scatter plot of horsepower versus miles per gallon, with a color encoding for the number cylinders in the car engine. . In addition, we&#39;ll create a selection instance by calling alt.selection_single(), indicating we want a selection defined over a single value. By default, the selection uses a mouse click to determine the selected value. To register a selection with a chart, we must add it using the .add_selection() method. . Once our selection has been defined, we can use it as a parameter for conditional encodings, which apply a different encoding depending on whether a data record lies in or out of the selection. For example, consider the following code: . color=alt.condition(selection, &#39;Cylinders:O&#39;, alt.value(&#39;grey&#39;)) . This encoding definition states that data points contained within the selection should be colored according to the Cylinder field, while non-selected data points should use a default grey. An empty selection includes all data points, and so initially all points will be colored. . Try clicking different points in the chart below. What happens? (Click the background to clear the selection state and return to an &quot;empty&quot; selection.) . selection = alt.selection_single(); ( alt.Chart(cars).mark_circle().add_selection(selection) .encode( x=&#39;Horsepower:Q&#39;, y=&#39;Miles_per_Gallon:Q&#39;, color=alt.condition(selection, &#39;Cylinders:O&#39;, alt.value(&#39;grey&#39;)), opacity=alt.condition(selection, alt.value(0.8), alt.value(0.1)) ) ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Of course, highlighting individual data points one-at-a-time is not particularly exciting! As we&#39;ll see, however, single value selections provide a useful building block for more powerful interactions. Moreover, single value selections are just one of the three selection types provided by Altair: . selection_single - select a single discrete value, by default on click events. | selection_multi - select multiple discrete values. The first value is selected on mouse click and additional values toggled using shift-click. | selection_interval - select a continuous range of values, initiated by mouse drag. | . Let&#39;s compare each of these selection types side-by-side. To keep our code tidy we&#39;ll first define a function (plot) that generates a scatter plot specification just like the one above. We can pass a selection to the plot function to have it applied to the chart: . def plot(selection): return alt.Chart(cars).mark_circle().add_selection( selection ).encode( x=&#39;Horsepower:Q&#39;, y=&#39;Miles_per_Gallon:Q&#39;, color=alt.condition(selection, &#39;Cylinders:O&#39;, alt.value(&#39;grey&#39;)), opacity=alt.condition(selection, alt.value(0.8), alt.value(0.1)) ).properties( width=240, height=180 ) . Let&#39;s use our plot function to create three chart variants, one per selection type. . The first (single) chart replicates our earlier example. The second (multi) chart supports shift-click interactions to toggle inclusion of multiple points within the selection. The third (interval) chart generates a selection region (or brush) upon mouse drag. Once created, you can drag the brush around to select different points, or scroll when the cursor is inside the brush to scale (zoom) the brush size. . Try interacting with each of the charts below! . alt.hconcat( plot(alt.selection_single()).properties(title=&#39;Single (Click)&#39;), plot(alt.selection_multi()).properties(title=&#39;Multi (Shift-Click)&#39;), plot(alt.selection_interval()).properties(title=&#39;Interval (Drag)&#39;) ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . The examples above use default interactions (click, shift-click, drag) for each selection type. We can further customize the interactions by providing input event specifications using Vega event selector syntax. For example, we can modify our single and multi charts to trigger upon mouseover events instead of click events. . Hold down the shift key in the second chart to &quot;paint&quot; with data! . alt.hconcat( plot(alt.selection_single(on=&#39;mouseover&#39;)).properties(title=&#39;Single (Mouseover)&#39;), plot(alt.selection_multi(on=&#39;mouseover&#39;)).properties(title=&#39;Multi (Shift-Mouseover)&#39;) ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Now that we&#39;ve covered the basics of Altair selections, let&#39;s take a tour through the various interaction techniques they enable! . Dynamic Queries . Dynamic queries enables rapid, reversible exploration of data to isolate patterns of interest. As defined by Ahlberg, Williamson, &amp; Shneiderman, a dynamic query: . represents a query graphically, | provides visible limits on the query range, | provides a graphical representation of the data and query result, | gives immediate feedback of the result after every query adjustment, | and allows novice users to begin working with little training. | . A common approach is to manipulate query parameters using standard user interface widgets such as sliders, radio buttons, and drop-down menus. To generate dynamic query widgets, we can apply a selection&#39;s bind operation to one or more data fields we wish to query. . Let&#39;s build an interactive scatter plot that uses a dynamic query to filter the display. Given a scatter plot of movie ratings (from Rotten Tomates and IMDB), we can add a selection over the Major Genre field to enable interactive filtering by film genre. . To start, let&#39;s extract the unique (non-null) genres from the movies data: . df = pd.read_json(movies) # load movies data genres = df[&#39;Major Genre&#39;].unique() # get unique field values genres = list(filter(lambda d: d is not None, genres)) # filter out None values genres.sort() # sort alphabetically . For later use, let&#39;s also define a list of unique MPAA_Rating values: . mpaa = [&#39;G&#39;, &#39;PG&#39;, &#39;PG-13&#39;, &#39;R&#39;, &#39;NC-17&#39;, &#39;Not Rated&#39;] . Now let&#39;s create a single selection bound to a drop-down menu. . Use the dynamic query menu below to explore the data. How do ratings vary by genre? How would you revise the code to filter MPAA_Rating (G, PG, PG-13, etc.) instead of Major Genre? . selectGenre = alt.selection_single( name=&#39;Select&#39;, # name the selection &#39;Select&#39; fields=[&#39;Major Genre&#39;], # limit selection to the Major Genre field init={&#39;Major Genre&#39;: genres[0]}, # use first genre entry as initial value bind=alt.binding_select(options=genres) # bind to a menu of unique genre values ) alt.Chart(movies).mark_circle().add_selection( selectGenre ).encode( x=&#39;Rotten Tomatoes Rating:Q&#39;, y=&#39;IMDB Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selectGenre, alt.value(0.75), alt.value(0.05)) ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Our construction above leverages multiple aspects of selections: . We give the selection a name (&#39;Select&#39;). This name is not required, but allows us to influence the label text of the generated dynamic query menu. (What happens if you remove the name? Try it!) | We constrain the selection to a specific data field (Major Genre). Earlier when we used a single selection, the selection mapped to individual data points. By limiting the selection to a specific field, we can select all data points whose Major Genre field value matches the single selected value. | We initialize init=... the selection to a starting value. | We bind the selection to an interface widget, in this case a drop-down menu via binding_select. | As before, we then use a conditional encoding to control the opacity channel. | . Binding Selections to Multiple Inputs . One selection instance can be bound to multiple dynamic query widgets. Let&#39;s modify the example above to provide filters for both Major Genre and MPAA_Rating, using radio buttons instead of a menu. Our single selection is now defined over a single pair of genre and MPAA rating values . Look for surprising conjunctions of genre and rating. Are there any G or PG-rated horror films? . # single-value selection over [Major Genre, MPAA_Rating] pairs # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(movies).mark_circle().add_selection( selection ).encode( x=&#39;Rotten Tomatoes Rating:Q&#39;, y=&#39;IMDB Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Fun facts: The PG-13 rating didn&#39;t exist when the movies Jaws and Jaws 2 were released. The first film to receive a PG-13 rating was 1984&#39;s Red Dawn. . Using Visualizations as Dynamic Queries . Though standard interface widgets show the possible query parameter values, they do not visualize the distribution of those values. We might also wish to use richer interactions, such as multi-value or interval selections, rather than input widgets that select only a single value at a time. . To address these issues, we can author additional charts to both visualize data and support dynamic queries. Let&#39;s add a histogram of the count of films per year and use an interval selection to dynamically highlight films over selected time periods. . Interact with the year histogram to explore films from different time periods. Do you seen any evidence of sampling bias across the years? (How do year and critics&#39; ratings relate?) . The years range from 1930 to 2040! Are future films in pre-production, or are there &quot;off-by-one century&quot; errors? Also, depending on which time zone you&#39;re in, you may see a small bump in either 1969 or 1970. Why might that be? (See the end of the notebook for an explanation!) . brush = alt.selection_interval( encodings=[&#39;x&#39;] # limit selection to x-axis (year) values ) # dynamic query histogram years = alt.Chart(movies).mark_bar().add_selection( brush ).encode( alt.X(&#39;year(Release Date):T&#39;, title=&#39;Films by Release Year&#39;), alt.Y(&#39;count():Q&#39;, title=None) ).properties( width=650, height=50 ) # scatter plot, modify opacity based on selection ratings = alt.Chart(movies).mark_circle().encode( x=&#39;Rotten Tomatoes Rating:Q&#39;, y=&#39;IMDB Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(brush, alt.value(0.75), alt.value(0.05)) ).properties( width=650, height=400 ) alt.vconcat(years, ratings).properties(spacing=5) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . The example above provides dynamic queries using a linked selection between charts: . We create an interval selection (brush), and set encodings=[&#39;x&#39;] to limit the selection to the x-axis only, resulting in a one-dimensional selection interval. | We register brush with our histogram of films per year via .add_selection(brush). | We use brush in a conditional encoding to adjust the scatter plot opacity. | . This interaction technique of selecting elements in one chart and seeing linked highlights in one or more other charts is known as brushing &amp; linking. . Panning &amp; Zooming . The movie rating scatter plot is a bit cluttered in places, making it hard to examine points in denser regions. Using the interaction techniques of panning and zooming, we can inspect dense regions more closely. . Let&#39;s start by thinking about how we might express panning and zooming using Altair selections. What defines the &quot;viewport&quot; of a chart? Axis scale domains! . We can change the scale domains to modify the visualized range of data values. To do so interactively, we can bind an interval selection to scale domains with the code bind=&#39;scales&#39;. The result is that instead of an interval brush that we can drag and zoom, we instead can drag and zoom the entire plotting area! . In the chart below, click and drag to pan (translate) the view, or scroll to zoom (scale) the view. What can you discover about the precision of the provided rating values? . alt.Chart(movies).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;) ).encode( x=&#39;Rotten Tomatoes Rating:Q&#39;, y=alt.Y(&#39;IMDB Rating:Q&#39;, axis=alt.Axis(minExtent=30)), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release Date:N&#39;, &#39;IMDB Rating:Q&#39;, &#39;Rotten Tomatoes Rating:Q&#39;] ).properties( width=600, height=400 ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Zooming in, we can see that the rating values have limited precision! The Rotten Tomatoes ratings are integers, while the IMDB ratings are truncated to tenths. As a result, there is overplotting even when we zoom, with multiple movies sharing the same rating values. . Reading the code above, you may notice the code alt.Axis(minExtent=30) in the y encoding channel. The minExtent parameter ensures a minimum amount of space is reserved for axis ticks and labels. Why do this? When we pan and zoom, the axis labels may change and cause the axis title position to shift. By setting a minimum extent we can reduce distracting movements in the plot. Try changing the minExtent value, for example setting it to zero, and then zoom out to see what happens when longer axis labels enter the view. . Altair also includes a shorthand for adding panning and zooming to a plot. Instead of directly creating a selection, you can call .interactive() to have Altair automatically generate an interval selection bound to the chart&#39;s scales: . alt.Chart(movies).mark_circle().encode( x=&#39;Rotten Tomatoes Rating:Q&#39;, y=alt.Y(&#39;IMDB Rating:Q&#39;, axis=alt.Axis(minExtent=30)), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release Date:N&#39;, &#39;IMDB Rating:Q&#39;, &#39;Rotten Tomatoes Rating:Q&#39;] ).properties( width=600, height=400 ).interactive() . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . By default, scale bindings for selections include both the x and y encoding channels. What if we want to limit panning and zooming along a single dimension? We can invoke encodings=[&#39;x&#39;] to constrain the selection to the x channel only: . alt.Chart(movies).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( x=&#39;Rotten Tomatoes Rating:Q&#39;, y=alt.Y(&#39;IMDB Rating:Q&#39;, axis=alt.Axis(minExtent=30)), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release Date:N&#39;, &#39;IMDB Rating:Q&#39;, &#39;Rotten Tomatoes Rating:Q&#39;] ).properties( width=600, height=400 ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . When zooming along a single axis only, the shape of the visualized data can change, potentially affecting our perception of relationships in the data. Choosing an appropriate aspect ratio is an important visualization design concern! . Navigation: Overview + Detail . When panning and zooming, we directly adjust the &quot;viewport&quot; of a chart. The related navigation strategy of overview + detail instead uses an overview display to show all of the data, while supporting selections that pan and zoom a separate focus display. . Below we have two area charts showing a decade of price fluctuations for the S&amp;P 500 stock index. Initially both charts show the same data range. Click and drag in the bottom overview chart to update the focus display and examine specific time spans. . brush = alt.selection_interval(encodings=[&#39;x&#39;]); base = alt.Chart().mark_area().encode( alt.X(&#39;date:T&#39;, title=None), alt.Y(&#39;price:Q&#39;) ).properties( width=700 ) alt.vconcat( base.encode(alt.X(&#39;date:T&#39;, title=None, scale=alt.Scale(domain=brush))), base.add_selection(brush).properties(height=60), data=sp500 ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Unlike our earlier panning &amp; zooming case, here we don&#39;t want to bind a selection directly to the scales of a single interactive chart. Instead, we want to bind the selection to a scale domain in another chart. To do so, we update the x encoding channel for our focus chart, setting the scale domain property to reference our brush selection. If no interval is defined (the selection is empty), Altair ignores the brush and uses the underlying data to determine the domain. When a brush interval is created, Altair instead uses that as the scale domain for the focus chart. . Details on Demand . Once we spot points of interest within a visualization, we often want to know more about them. Details-on-demand refers to interactively querying for more information about selected values. Tooltips are one useful means of providing details on demand. However, tooltips typically only show information for one data point at a time. How might we show more? . The movie ratings scatterplot includes a number of potentially interesting outliers where the Rotten Tomatoes and IMDB ratings disagree. Let&#39;s create a plot that allows us to interactively select points and show their labels. . Mouse over points in the scatter plot below to see a highlight and title label. Shift-click points to make annotations persistent and view multiple labels at once. Which movies are loved by Rotten Tomatoes critics, but not the general audience on IMDB (or vice versa)? See if you can find possible errors, where two different movies with the same name were accidentally combined! . hover = alt.selection_single( on=&#39;mouseover&#39;, # select on mouseover nearest=True, # select nearest point to mouse cursor empty=&#39;none&#39; # empty selection should match nothing ) click = alt.selection_multi( empty=&#39;none&#39; # empty selection matches no points ) # scatter plot encodings shared by all marks plot = alt.Chart().mark_circle().encode( x=&#39;Rotten Tomatoes Rating:Q&#39;, y=&#39;IMDB Rating:Q&#39; ) # shared base for new layers base = plot.transform_filter( # logical OR is supported by Vega-Lite, nice syntax still needed for Altair {&#39;or&#39;: [hover, click]} # filter to points in either selection ) # layer scatter plot points, halo annotations, and title labels alt.layer( plot.add_selection(hover).add_selection(click), base.mark_point(size=100, stroke=&#39;firebrick&#39;, strokeWidth=1), base.mark_text(dx=4, dy=-8, align=&#39;right&#39;, stroke=&#39;white&#39;, strokeWidth=2).encode(text=&#39;Title:N&#39;), base.mark_text(dx=4, dy=-8, align=&#39;right&#39;).encode(text=&#39;Title:N&#39;), data=movies ).properties( width=600, height=450 ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . The example above adds three new layers to the scatter plot: a circular annotation, white text to provide a legible background, and black text showing a film title. In addition, this example uses two selections in tandem: . A single selection (hover) that includes nearest=True to automatically select the nearest data point as the mouse moves. | A multi selection (click) to create persistent selections via shift-click. | Both selections include the set empty=&#39;none&#39; to indicate that no points should be included if a selection is empty. These selections are then combined into a single filter predicate &mdash; the logical or of hover and click &mdash; to include points that reside in either selection. We use this predicate to filter the new layers to show annotations and labels for selected points only. . Using selections and layers, we can realize a number of different designs for details on demand! For example, here is a log-scaled time series of technology stock prices, annotated with a guideline and labels for the date nearest the mouse cursor: . # select a point for which to provide details-on-demand label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=700, height=400 ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Putting into action what we&#39;ve learned so far: can you modify the movie scatter plot above (the one with the dynamic query over years) to include a rule mark that shows the average IMDB (or Rotten Tomatoes) rating for the data contained within the year interval selection? . Brushing &amp; Linking, Revisited . Earlier in this notebook we saw an example of brushing &amp; linking: using a dynamic query histogram to highlight points in a movie rating scatter plot. Here, we&#39;ll visit some additional examples involving linked selections. . Returning to the cars dataset, we can use the repeat operator to build a scatter plot matrix (SPLOM) that shows associations between mileage, acceleration, and horsepower. We can define an interval selection and include it within our repeated scatter plot specification to enable linked selections among all the plots. . Click and drag in any of the plots below to perform brushing &amp; linking! . brush = alt.selection_interval( resolve=&#39;global&#39; # resolve all selections to a single global instance ) alt.Chart(cars).mark_circle().add_selection( brush ).encode( alt.X(alt.repeat(&#39;column&#39;), type=&#39;quantitative&#39;), alt.Y(alt.repeat(&#39;row&#39;), type=&#39;quantitative&#39;), color=alt.condition(brush, &#39;Cylinders:O&#39;, alt.value(&#39;grey&#39;)), opacity=alt.condition(brush, alt.value(0.8), alt.value(0.1)) ).properties( width=140, height=140 ).repeat( column=[&#39;Acceleration&#39;, &#39;Horsepower&#39;, &#39;Miles_per_Gallon&#39;], row=[&#39;Miles_per_Gallon&#39;, &#39;Horsepower&#39;, &#39;Acceleration&#39;] ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Note above the use of resolve=&#39;global&#39; on the interval selection. The default setting of &#39;global&#39; indicates that across all plots only one brush can be active at a time. However, in some cases we might want to define brushes in multiple plots and combine the results. If we use resolve=&#39;union&#39;, the selection will be the union of all brushes: if a point resides within any brush it will be selected. Alternatively, if we use resolve=&#39;intersect&#39;, the selection will consist of the intersection of all brushes: only points that reside within all brushes will be selected. . Try setting the resolve parameter to &#39;union&#39; and &#39;intersect&#39; and see how it changes the resulting selection logic. . Cross-Filtering . The brushing &amp; linking examples we&#39;ve looked at all use conditional encodings, for example to change opacity values in response to a selection. Another option is to use a selection defined in one view to filter the content of another view. . Let&#39;s build a collection of histograms for the flights dataset: arrival delay (how early or late a flight arrives, in minutes), distance flown (in miles), and time of departure (hour of the day). We&#39;ll use the repeat operator to create the histograms, and add an interval selection for the x axis with brushes resolved via intersection. . In particular, each histogram will consist of two layers: a gray background layer and a blue foreground layer, with the foreground layer filtered by our intersection of brush selections. The result is a cross-filtering interaction across the three charts! . Drag out brush intervals in the charts below. As you select flights with longer or shorter arrival delays, how do the distance and time distributions respond? . brush = alt.selection_interval( encodings=[&#39;x&#39;], resolve=&#39;intersect&#39; ); hist = alt.Chart().mark_bar().encode( alt.X(alt.repeat(&#39;row&#39;), type=&#39;quantitative&#39;, bin=alt.Bin(maxbins=100, minstep=1), # up to 100 bins axis=alt.Axis(format=&#39;d&#39;, titleAnchor=&#39;start&#39;) # integer format, left-aligned title ), alt.Y(&#39;count():Q&#39;, title=None) # no y-axis title ) alt.layer( hist.add_selection(brush).encode(color=alt.value(&#39;lightgrey&#39;)), hist.transform_filter(brush) ).properties( width=900, height=100 ).repeat( row=[&#39;delay&#39;, &#39;distance&#39;, &#39;time&#39;], data=flights ).transform_calculate( delay=&#39;datum.delay &lt; 180 ? datum.delay : 180&#39;, # clamp delays &gt; 3 hours time=&#39;hours(datum.date) + minutes(datum.date) / 60&#39; # fractional hours ).configure_view( stroke=&#39;transparent&#39; # no outline ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . By cross-filtering you can observe that delayed flights are more likely to depart at later hours. This phenomenon is familiar to frequent fliers: a delay can propagate through the day, affecting subsequent travel by that plane. For the best odds of an on-time arrival, book an early flight! . The combination of multiple views and interactive selections can enable valuable forms of multi-dimensional reasoning, turning even basic histograms into powerful input devices for asking questions of a dataset! . Summary . For more information about the supported interaction options in Altair, please consult the Altair interactive selection documentation. For details about customizing event handlers, for example to compose multiple interaction techniques or support touch-based input on mobile devices, see the Vega-Lite selection documentation. . Interested in learning more? . The selection abstraction was introduced in the paper Vega-Lite: A Grammar of Interactive Graphics, by Satyanarayan, Moritz, Wongsuphasawat, &amp; Heer. | The PRIM-9 system (for projection, rotation, isolation, and masking in up to 9 dimensions) is one of the earliest interactive visualization tools, built in the early 1970s by Fisherkeller, Tukey, &amp; Friedman. A retro demo video survives! | The concept of brushing &amp; linking was crystallized by Becker, Cleveland, &amp; Wilks in their 1987 article Dynamic Graphics for Data Analysis. | For a comprehensive summary of interaction techniques for visualization, see Interactive Dynamics for Visual Analysis by Heer &amp; Shneiderman. | Finally, for a treatise on what makes interaction effective, read the classic Direct Manipulation Interfaces paper by Hutchins, Hollan, &amp; Norman. | . Appendix: On The Representation of Time . Earlier we observed a small bump in the number of movies in either 1969 and 1970. Where does that bump come from? And why 1969 or 1970? The answer stems from a combination of missing data and how your computer represents time. . Internally, dates and times are represented relative to the UNIX epoch, in which time &quot;zero&quot; corresponds to the stroke of midnight on January 1, 1970 in UTC time, which runs along the prime meridian. It turns out there are a few movies with missing (null) release dates. Those null values get interpreted as time 0, and thus map to January 1, 1970 in UTC time. If you live in the Americas &ndash; and thus in &quot;earlier&quot; time zones &ndash; this precise point in time corresponds to an earlier hour on December 31, 1969 in your local time zone. On the other hand, if you live near or east of the prime meridian, the date in your local time zone will be January 1, 1970. . The takeaway? Always be skeptical of your data, and be mindful that how data is represented (whether as date times, or floating point numbers, or latitudes and longitudes, etc.) can sometimes lead to artifacts that impact analysis! .",
            "url": "andrasnovoszath.com/2020/09/21/altair_interaction.html",
            "relUrl": "/2020/09/21/altair_interaction.html",
            "date": " • Sep 21, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "How to categorize your notes?",
            "content": "I take notes . I take lots of notes. Many of them are ideas to research, explore, and think about, while others are rather tasks or possible projects. . As I collect them continuously, their number grows. After a while, it becomes hard to look through them and prioritize for action. . The obvious way to do this, of course, is to categorize them under topics or themes. . Concept hierarchies . This produces a hierarchical tree-like structure. There a few problems with this: . There always be some idea or task which does not belong to a single category alone but under multiple ones. | As the number of notes and, therefore, the number of categories and sub-categories becomes high, you need to dig very deep to find some notes. If the hierarchies are obvious, this is not really a problem. However, as the number of hierarchy levels and branches grow, the previous issue (i.e., notes belonging under multiple categories) become even more prominent. | . Concept drift . There is also the problem of concept drift. While we refer to a particular thing or category with a specific term, later on, we start to refer to it with a related but different one. Similarly, we do the same with categories. . This shift can happen for multiple reasons, but the most obvious ones are terminological shifts or our changing ‘use’ of the original idea or category. . Concept drift, deep hierarchies, and the overlapping category boundaries can lead to the ‘forgetting’ of notes. They can also lead to making multiple, ‘almost similar’ but ‘slightly different’ versions of them at different places of the hierarchy. . And, even whether the relationship between two ideas should be hierarchical or not also can change from use case to use case. . Chaos everywhere . And note-taking is just the most obvious example for me. I had the same experience with software development (both as writing code and managing versions), technical writing, academic research, work organization, file organization, etc. .",
            "url": "andrasnovoszath.com/note-taking/categorization/hierarchies/concept%20drift/chaos%20&%20order/2020/09/20/note-categorization-pain.html",
            "relUrl": "/note-taking/categorization/hierarchies/concept%20drift/chaos%20&%20order/2020/09/20/note-categorization-pain.html",
            "date": " • Sep 20, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "Interaction",
            "content": "import pandas as pd import altair as alt . Datasets . We will visualize a variety of datasets from the vega-datasets collection: . A dataset of cars from the 1970s and early 1980s, | A dataset of movies, previously used in the Data Transformation notebook, | A dataset containing ten years of S&amp;P 500 (sp500) stock prices, | A dataset of technology company stocks, and | A dataset of flights, including departure time, distance, and arrival delay. | . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . Introducing Selections . Let&#39;s start with a basic selection: simply clicking a point to highlight it. Using the cars dataset, we&#39;ll start with a scatter plot of horsepower versus miles per gallon, with a color encoding for the number cylinders in the car engine. . In addition, we&#39;ll create a selection instance by calling alt.selection_single(), indicating we want a selection defined over a single value. By default, the selection uses a mouse click to determine the selected value. To register a selection with a chart, we must add it using the .add_selection() method. . Once our selection has been defined, we can use it as a parameter for conditional encodings, which apply a different encoding depending on whether a data record lies in or out of the selection. For example, consider the following code: . color=alt.condition(selection, &#39;Cylinders:O&#39;, alt.value(&#39;grey&#39;)) . This encoding definition states that data points contained within the selection should be colored according to the Cylinder field, while non-selected data points should use a default grey. An empty selection includes all data points, and so initially all points will be colored. . Try clicking different points in the chart below. What happens? (Click the background to clear the selection state and return to an &quot;empty&quot; selection.) . selection = alt.selection_single(); ( alt.Chart(cars).mark_circle().add_selection(selection) .encode( x=&#39;Horsepower:Q&#39;, y=&#39;Miles_per_Gallon:Q&#39;, color=alt.condition(selection, &#39;Cylinders:O&#39;, alt.value(&#39;grey&#39;)), opacity=alt.condition(selection, alt.value(0.8), alt.value(0.1)) ) ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Of course, highlighting individual data points one-at-a-time is not particularly exciting! As we&#39;ll see, however, single value selections provide a useful building block for more powerful interactions. Moreover, single value selections are just one of the three selection types provided by Altair: . selection_single - select a single discrete value, by default on click events. | selection_multi - select multiple discrete values. The first value is selected on mouse click and additional values toggled using shift-click. | selection_interval - select a continuous range of values, initiated by mouse drag. | . Let&#39;s compare each of these selection types side-by-side. To keep our code tidy we&#39;ll first define a function (plot) that generates a scatter plot specification just like the one above. We can pass a selection to the plot function to have it applied to the chart: . def plot(selection): return alt.Chart(cars).mark_circle().add_selection( selection ).encode( x=&#39;Horsepower:Q&#39;, y=&#39;Miles_per_Gallon:Q&#39;, color=alt.condition(selection, &#39;Cylinders:O&#39;, alt.value(&#39;grey&#39;)), opacity=alt.condition(selection, alt.value(0.8), alt.value(0.1)) ).properties( width=240, height=180 ) . Let&#39;s use our plot function to create three chart variants, one per selection type. . The first (single) chart replicates our earlier example. The second (multi) chart supports shift-click interactions to toggle inclusion of multiple points within the selection. The third (interval) chart generates a selection region (or brush) upon mouse drag. Once created, you can drag the brush around to select different points, or scroll when the cursor is inside the brush to scale (zoom) the brush size. . Try interacting with each of the charts below! . alt.hconcat( plot(alt.selection_single()).properties(title=&#39;Single (Click)&#39;), plot(alt.selection_multi()).properties(title=&#39;Multi (Shift-Click)&#39;), plot(alt.selection_interval()).properties(title=&#39;Interval (Drag)&#39;) ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . The examples above use default interactions (click, shift-click, drag) for each selection type. We can further customize the interactions by providing input event specifications using Vega event selector syntax. For example, we can modify our single and multi charts to trigger upon mouseover events instead of click events. . Hold down the shift key in the second chart to &quot;paint&quot; with data! . alt.hconcat( plot(alt.selection_single(on=&#39;mouseover&#39;)).properties(title=&#39;Single (Mouseover)&#39;), plot(alt.selection_multi(on=&#39;mouseover&#39;)).properties(title=&#39;Multi (Shift-Mouseover)&#39;) ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Now that we&#39;ve covered the basics of Altair selections, let&#39;s take a tour through the various interaction techniques they enable! . Dynamic Queries . Dynamic queries enables rapid, reversible exploration of data to isolate patterns of interest. As defined by Ahlberg, Williamson, &amp; Shneiderman, a dynamic query: . represents a query graphically, | provides visible limits on the query range, | provides a graphical representation of the data and query result, | gives immediate feedback of the result after every query adjustment, | and allows novice users to begin working with little training. | . A common approach is to manipulate query parameters using standard user interface widgets such as sliders, radio buttons, and drop-down menus. To generate dynamic query widgets, we can apply a selection&#39;s bind operation to one or more data fields we wish to query. . Let&#39;s build an interactive scatter plot that uses a dynamic query to filter the display. Given a scatter plot of movie ratings (from Rotten Tomates and IMDB), we can add a selection over the Major Genre field to enable interactive filtering by film genre. . To start, let&#39;s extract the unique (non-null) genres from the movies data: . df = pd.read_json(movies) # load movies data genres = df[&#39;Major Genre&#39;].unique() # get unique field values genres = list(filter(lambda d: d is not None, genres)) # filter out None values genres.sort() # sort alphabetically . For later use, let&#39;s also define a list of unique MPAA_Rating values: . mpaa = [&#39;G&#39;, &#39;PG&#39;, &#39;PG-13&#39;, &#39;R&#39;, &#39;NC-17&#39;, &#39;Not Rated&#39;] . Now let&#39;s create a single selection bound to a drop-down menu. . Use the dynamic query menu below to explore the data. How do ratings vary by genre? How would you revise the code to filter MPAA_Rating (G, PG, PG-13, etc.) instead of Major Genre? . selectGenre = alt.selection_single( name=&#39;Select&#39;, # name the selection &#39;Select&#39; fields=[&#39;Major Genre&#39;], # limit selection to the Major Genre field init={&#39;Major Genre&#39;: genres[0]}, # use first genre entry as initial value bind=alt.binding_select(options=genres) # bind to a menu of unique genre values ) alt.Chart(movies).mark_circle().add_selection( selectGenre ).encode( x=&#39;Rotten Tomatoes Rating:Q&#39;, y=&#39;IMDB Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selectGenre, alt.value(0.75), alt.value(0.05)) ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Our construction above leverages multiple aspects of selections: . We give the selection a name (&#39;Select&#39;). This name is not required, but allows us to influence the label text of the generated dynamic query menu. (What happens if you remove the name? Try it!) | We constrain the selection to a specific data field (Major Genre). Earlier when we used a single selection, the selection mapped to individual data points. By limiting the selection to a specific field, we can select all data points whose Major Genre field value matches the single selected value. | We initialize init=... the selection to a starting value. | We bind the selection to an interface widget, in this case a drop-down menu via binding_select. | As before, we then use a conditional encoding to control the opacity channel. | . Binding Selections to Multiple Inputs . One selection instance can be bound to multiple dynamic query widgets. Let&#39;s modify the example above to provide filters for both Major Genre and MPAA_Rating, using radio buttons instead of a menu. Our single selection is now defined over a single pair of genre and MPAA rating values . Look for surprising conjunctions of genre and rating. Are there any G or PG-rated horror films? . # single-value selection over [Major Genre, MPAA_Rating] pairs # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(movies).mark_circle().add_selection( selection ).encode( x=&#39;Rotten Tomatoes Rating:Q&#39;, y=&#39;IMDB Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Fun facts: The PG-13 rating didn&#39;t exist when the movies Jaws and Jaws 2 were released. The first film to receive a PG-13 rating was 1984&#39;s Red Dawn. . Using Visualizations as Dynamic Queries . Though standard interface widgets show the possible query parameter values, they do not visualize the distribution of those values. We might also wish to use richer interactions, such as multi-value or interval selections, rather than input widgets that select only a single value at a time. . To address these issues, we can author additional charts to both visualize data and support dynamic queries. Let&#39;s add a histogram of the count of films per year and use an interval selection to dynamically highlight films over selected time periods. . Interact with the year histogram to explore films from different time periods. Do you seen any evidence of sampling bias across the years? (How do year and critics&#39; ratings relate?) . The years range from 1930 to 2040! Are future films in pre-production, or are there &quot;off-by-one century&quot; errors? Also, depending on which time zone you&#39;re in, you may see a small bump in either 1969 or 1970. Why might that be? (See the end of the notebook for an explanation!) . brush = alt.selection_interval( encodings=[&#39;x&#39;] # limit selection to x-axis (year) values ) # dynamic query histogram years = alt.Chart(movies).mark_bar().add_selection( brush ).encode( alt.X(&#39;year(Release Date):T&#39;, title=&#39;Films by Release Year&#39;), alt.Y(&#39;count():Q&#39;, title=None) ).properties( width=650, height=50 ) # scatter plot, modify opacity based on selection ratings = alt.Chart(movies).mark_circle().encode( x=&#39;Rotten Tomatoes Rating:Q&#39;, y=&#39;IMDB Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(brush, alt.value(0.75), alt.value(0.05)) ).properties( width=650, height=400 ) alt.vconcat(years, ratings).properties(spacing=5) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . The example above provides dynamic queries using a linked selection between charts: . We create an interval selection (brush), and set encodings=[&#39;x&#39;] to limit the selection to the x-axis only, resulting in a one-dimensional selection interval. | We register brush with our histogram of films per year via .add_selection(brush). | We use brush in a conditional encoding to adjust the scatter plot opacity. | . This interaction technique of selecting elements in one chart and seeing linked highlights in one or more other charts is known as brushing &amp; linking. . Panning &amp; Zooming . The movie rating scatter plot is a bit cluttered in places, making it hard to examine points in denser regions. Using the interaction techniques of panning and zooming, we can inspect dense regions more closely. . Let&#39;s start by thinking about how we might express panning and zooming using Altair selections. What defines the &quot;viewport&quot; of a chart? Axis scale domains! . We can change the scale domains to modify the visualized range of data values. To do so interactively, we can bind an interval selection to scale domains with the code bind=&#39;scales&#39;. The result is that instead of an interval brush that we can drag and zoom, we instead can drag and zoom the entire plotting area! . In the chart below, click and drag to pan (translate) the view, or scroll to zoom (scale) the view. What can you discover about the precision of the provided rating values? . alt.Chart(movies).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;) ).encode( x=&#39;Rotten Tomatoes Rating:Q&#39;, y=alt.Y(&#39;IMDB Rating:Q&#39;, axis=alt.Axis(minExtent=30)), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release Date:N&#39;, &#39;IMDB Rating:Q&#39;, &#39;Rotten Tomatoes Rating:Q&#39;] ).properties( width=600, height=400 ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Zooming in, we can see that the rating values have limited precision! The Rotten Tomatoes ratings are integers, while the IMDB ratings are truncated to tenths. As a result, there is overplotting even when we zoom, with multiple movies sharing the same rating values. . Reading the code above, you may notice the code alt.Axis(minExtent=30) in the y encoding channel. The minExtent parameter ensures a minimum amount of space is reserved for axis ticks and labels. Why do this? When we pan and zoom, the axis labels may change and cause the axis title position to shift. By setting a minimum extent we can reduce distracting movements in the plot. Try changing the minExtent value, for example setting it to zero, and then zoom out to see what happens when longer axis labels enter the view. . Altair also includes a shorthand for adding panning and zooming to a plot. Instead of directly creating a selection, you can call .interactive() to have Altair automatically generate an interval selection bound to the chart&#39;s scales: . alt.Chart(movies).mark_circle().encode( x=&#39;Rotten Tomatoes Rating:Q&#39;, y=alt.Y(&#39;IMDB Rating:Q&#39;, axis=alt.Axis(minExtent=30)), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release Date:N&#39;, &#39;IMDB Rating:Q&#39;, &#39;Rotten Tomatoes Rating:Q&#39;] ).properties( width=600, height=400 ).interactive() . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . By default, scale bindings for selections include both the x and y encoding channels. What if we want to limit panning and zooming along a single dimension? We can invoke encodings=[&#39;x&#39;] to constrain the selection to the x channel only: . alt.Chart(movies).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( x=&#39;Rotten Tomatoes Rating:Q&#39;, y=alt.Y(&#39;IMDB Rating:Q&#39;, axis=alt.Axis(minExtent=30)), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release Date:N&#39;, &#39;IMDB Rating:Q&#39;, &#39;Rotten Tomatoes Rating:Q&#39;] ).properties( width=600, height=400 ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . When zooming along a single axis only, the shape of the visualized data can change, potentially affecting our perception of relationships in the data. Choosing an appropriate aspect ratio is an important visualization design concern! . Navigation: Overview + Detail . When panning and zooming, we directly adjust the &quot;viewport&quot; of a chart. The related navigation strategy of overview + detail instead uses an overview display to show all of the data, while supporting selections that pan and zoom a separate focus display. . Below we have two area charts showing a decade of price fluctuations for the S&amp;P 500 stock index. Initially both charts show the same data range. Click and drag in the bottom overview chart to update the focus display and examine specific time spans. . brush = alt.selection_interval(encodings=[&#39;x&#39;]); base = alt.Chart().mark_area().encode( alt.X(&#39;date:T&#39;, title=None), alt.Y(&#39;price:Q&#39;) ).properties( width=700 ) alt.vconcat( base.encode(alt.X(&#39;date:T&#39;, title=None, scale=alt.Scale(domain=brush))), base.add_selection(brush).properties(height=60), data=sp500 ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Unlike our earlier panning &amp; zooming case, here we don&#39;t want to bind a selection directly to the scales of a single interactive chart. Instead, we want to bind the selection to a scale domain in another chart. To do so, we update the x encoding channel for our focus chart, setting the scale domain property to reference our brush selection. If no interval is defined (the selection is empty), Altair ignores the brush and uses the underlying data to determine the domain. When a brush interval is created, Altair instead uses that as the scale domain for the focus chart. . Details on Demand . Once we spot points of interest within a visualization, we often want to know more about them. Details-on-demand refers to interactively querying for more information about selected values. Tooltips are one useful means of providing details on demand. However, tooltips typically only show information for one data point at a time. How might we show more? . The movie ratings scatterplot includes a number of potentially interesting outliers where the Rotten Tomatoes and IMDB ratings disagree. Let&#39;s create a plot that allows us to interactively select points and show their labels. . Mouse over points in the scatter plot below to see a highlight and title label. Shift-click points to make annotations persistent and view multiple labels at once. Which movies are loved by Rotten Tomatoes critics, but not the general audience on IMDB (or vice versa)? See if you can find possible errors, where two different movies with the same name were accidentally combined! . hover = alt.selection_single( on=&#39;mouseover&#39;, # select on mouseover nearest=True, # select nearest point to mouse cursor empty=&#39;none&#39; # empty selection should match nothing ) click = alt.selection_multi( empty=&#39;none&#39; # empty selection matches no points ) # scatter plot encodings shared by all marks plot = alt.Chart().mark_circle().encode( x=&#39;Rotten Tomatoes Rating:Q&#39;, y=&#39;IMDB Rating:Q&#39; ) # shared base for new layers base = plot.transform_filter( # logical OR is supported by Vega-Lite, nice syntax still needed for Altair {&#39;or&#39;: [hover, click]} # filter to points in either selection ) # layer scatter plot points, halo annotations, and title labels alt.layer( plot.add_selection(hover).add_selection(click), base.mark_point(size=100, stroke=&#39;firebrick&#39;, strokeWidth=1), base.mark_text(dx=4, dy=-8, align=&#39;right&#39;, stroke=&#39;white&#39;, strokeWidth=2).encode(text=&#39;Title:N&#39;), base.mark_text(dx=4, dy=-8, align=&#39;right&#39;).encode(text=&#39;Title:N&#39;), data=movies ).properties( width=600, height=450 ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . The example above adds three new layers to the scatter plot: a circular annotation, white text to provide a legible background, and black text showing a film title. In addition, this example uses two selections in tandem: . A single selection (hover) that includes nearest=True to automatically select the nearest data point as the mouse moves. | A multi selection (click) to create persistent selections via shift-click. | Both selections include the set empty=&#39;none&#39; to indicate that no points should be included if a selection is empty. These selections are then combined into a single filter predicate &mdash; the logical or of hover and click &mdash; to include points that reside in either selection. We use this predicate to filter the new layers to show annotations and labels for selected points only. . Using selections and layers, we can realize a number of different designs for details on demand! For example, here is a log-scaled time series of technology stock prices, annotated with a guideline and labels for the date nearest the mouse cursor: . # select a point for which to provide details-on-demand label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=700, height=400 ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Putting into action what we&#39;ve learned so far: can you modify the movie scatter plot above (the one with the dynamic query over years) to include a rule mark that shows the average IMDB (or Rotten Tomatoes) rating for the data contained within the year interval selection? . Brushing &amp; Linking, Revisited . Earlier in this notebook we saw an example of brushing &amp; linking: using a dynamic query histogram to highlight points in a movie rating scatter plot. Here, we&#39;ll visit some additional examples involving linked selections. . Returning to the cars dataset, we can use the repeat operator to build a scatter plot matrix (SPLOM) that shows associations between mileage, acceleration, and horsepower. We can define an interval selection and include it within our repeated scatter plot specification to enable linked selections among all the plots. . Click and drag in any of the plots below to perform brushing &amp; linking! . brush = alt.selection_interval( resolve=&#39;global&#39; # resolve all selections to a single global instance ) alt.Chart(cars).mark_circle().add_selection( brush ).encode( alt.X(alt.repeat(&#39;column&#39;), type=&#39;quantitative&#39;), alt.Y(alt.repeat(&#39;row&#39;), type=&#39;quantitative&#39;), color=alt.condition(brush, &#39;Cylinders:O&#39;, alt.value(&#39;grey&#39;)), opacity=alt.condition(brush, alt.value(0.8), alt.value(0.1)) ).properties( width=140, height=140 ).repeat( column=[&#39;Acceleration&#39;, &#39;Horsepower&#39;, &#39;Miles_per_Gallon&#39;], row=[&#39;Miles_per_Gallon&#39;, &#39;Horsepower&#39;, &#39;Acceleration&#39;] ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Note above the use of resolve=&#39;global&#39; on the interval selection. The default setting of &#39;global&#39; indicates that across all plots only one brush can be active at a time. However, in some cases we might want to define brushes in multiple plots and combine the results. If we use resolve=&#39;union&#39;, the selection will be the union of all brushes: if a point resides within any brush it will be selected. Alternatively, if we use resolve=&#39;intersect&#39;, the selection will consist of the intersection of all brushes: only points that reside within all brushes will be selected. . Try setting the resolve parameter to &#39;union&#39; and &#39;intersect&#39; and see how it changes the resulting selection logic. . Cross-Filtering . The brushing &amp; linking examples we&#39;ve looked at all use conditional encodings, for example to change opacity values in response to a selection. Another option is to use a selection defined in one view to filter the content of another view. . Let&#39;s build a collection of histograms for the flights dataset: arrival delay (how early or late a flight arrives, in minutes), distance flown (in miles), and time of departure (hour of the day). We&#39;ll use the repeat operator to create the histograms, and add an interval selection for the x axis with brushes resolved via intersection. . In particular, each histogram will consist of two layers: a gray background layer and a blue foreground layer, with the foreground layer filtered by our intersection of brush selections. The result is a cross-filtering interaction across the three charts! . Drag out brush intervals in the charts below. As you select flights with longer or shorter arrival delays, how do the distance and time distributions respond? . brush = alt.selection_interval( encodings=[&#39;x&#39;], resolve=&#39;intersect&#39; ); hist = alt.Chart().mark_bar().encode( alt.X(alt.repeat(&#39;row&#39;), type=&#39;quantitative&#39;, bin=alt.Bin(maxbins=100, minstep=1), # up to 100 bins axis=alt.Axis(format=&#39;d&#39;, titleAnchor=&#39;start&#39;) # integer format, left-aligned title ), alt.Y(&#39;count():Q&#39;, title=None) # no y-axis title ) alt.layer( hist.add_selection(brush).encode(color=alt.value(&#39;lightgrey&#39;)), hist.transform_filter(brush) ).properties( width=900, height=100 ).repeat( row=[&#39;delay&#39;, &#39;distance&#39;, &#39;time&#39;], data=flights ).transform_calculate( delay=&#39;datum.delay &lt; 180 ? datum.delay : 180&#39;, # clamp delays &gt; 3 hours time=&#39;hours(datum.date) + minutes(datum.date) / 60&#39; # fractional hours ).configure_view( stroke=&#39;transparent&#39; # no outline ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . By cross-filtering you can observe that delayed flights are more likely to depart at later hours. This phenomenon is familiar to frequent fliers: a delay can propagate through the day, affecting subsequent travel by that plane. For the best odds of an on-time arrival, book an early flight! . The combination of multiple views and interactive selections can enable valuable forms of multi-dimensional reasoning, turning even basic histograms into powerful input devices for asking questions of a dataset! . Summary . For more information about the supported interaction options in Altair, please consult the Altair interactive selection documentation. For details about customizing event handlers, for example to compose multiple interaction techniques or support touch-based input on mobile devices, see the Vega-Lite selection documentation. . Interested in learning more? . The selection abstraction was introduced in the paper Vega-Lite: A Grammar of Interactive Graphics, by Satyanarayan, Moritz, Wongsuphasawat, &amp; Heer. | The PRIM-9 system (for projection, rotation, isolation, and masking in up to 9 dimensions) is one of the earliest interactive visualization tools, built in the early 1970s by Fisherkeller, Tukey, &amp; Friedman. A retro demo video survives! | The concept of brushing &amp; linking was crystallized by Becker, Cleveland, &amp; Wilks in their 1987 article Dynamic Graphics for Data Analysis. | For a comprehensive summary of interaction techniques for visualization, see Interactive Dynamics for Visual Analysis by Heer &amp; Shneiderman. | Finally, for a treatise on what makes interaction effective, read the classic Direct Manipulation Interfaces paper by Hutchins, Hollan, &amp; Norman. | . Appendix: On The Representation of Time . Earlier we observed a small bump in the number of movies in either 1969 and 1970. Where does that bump come from? And why 1969 or 1970? The answer stems from a combination of missing data and how your computer represents time. . Internally, dates and times are represented relative to the UNIX epoch, in which time &quot;zero&quot; corresponds to the stroke of midnight on January 1, 1970 in UTC time, which runs along the prime meridian. It turns out there are a few movies with missing (null) release dates. Those null values get interpreted as time 0, and thus map to January 1, 1970 in UTC time. If you live in the Americas &ndash; and thus in &quot;earlier&quot; time zones &ndash; this precise point in time corresponds to an earlier hour on December 31, 1969 in your local time zone. On the other hand, if you live near or east of the prime meridian, the date in your local time zone will be January 1, 1970. . The takeaway? Always be skeptical of your data, and be mindful that how data is represented (whether as date times, or floating point numbers, or latitudes and longitudes, etc.) can sometimes lead to artifacts that impact analysis! .",
            "url": "andrasnovoszath.com/2020/09/20/altair_interaction.html",
            "relUrl": "/2020/09/20/altair_interaction.html",
            "date": " • Sep 20, 2020"
        }
        
    
  
    
        ,"post6": {
            "title": "Test notebook",
            "content": "import altair as alt alt.renderers . RendererRegistry(active=&#39;default&#39;, registered=[&#39;colab&#39;, &#39;default&#39;, &#39;json&#39;, &#39;jupyterlab&#39;, &#39;kaggle&#39;, &#39;nteract&#39;, &#39;png&#39;, &#39;svg&#39;, &#39;zeppelin&#39;]) . from vega_datasets import data . health_income = data(&#39;gapminder-health-income&#39;) health_income.head() . country income health population . 0 Afghanistan | 1925 | 57.63 | 32526562 | . 1 Albania | 10620 | 76.00 | 2896679 | . 2 Algeria | 13434 | 76.50 | 39666519 | . 3 Andorra | 46577 | 84.10 | 70473 | . 4 Angola | 7615 | 61.00 | 25021974 | . income_domain = [health_income[&#39;income&#39;].min(), health_income[&#39;income&#39;].max()] health_domain = [health_income[&#39;health&#39;].min(), health_income[&#39;health&#39;].max()] alt.Chart(health_income).mark_point().encode( alt.X(&#39;income:Q&#39;, scale=alt.Scale(domain=income_domain)), alt.Y(&#39;health:Q&#39;, scale=alt.Scale(domain=health_domain)), alt.Size(&#39;population:Q&#39;), alt.Tooltip(&#39;country:N&#39;) ).properties(height=600, width=800) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html .",
            "url": "andrasnovoszath.com/2020/09/20/_2020-09-21-test.html",
            "relUrl": "/2020/09/20/_2020-09-21-test.html",
            "date": " • Sep 20, 2020"
        }
        
    
  
    
        ,"post7": {
            "title": "Data scale normalization",
            "content": "Normalization is a common technique used in machine learning to render the scales of different magnitudes to a common range between 0 and 1. . Here we demonstrate how this is done with pandas and altair. . Original inspiration: (Jason Brownlee: Machine Learning Algorithms from Scratch)[https://machinelearningmastery.com/machine-learning-algorithms-from-scratch/] . import altair as alt # alt.renderers.enable(&#39;default&#39;) alt.renderers . RendererRegistry(active=&#39;default&#39;, registered=[&#39;colab&#39;, &#39;default&#39;, &#39;json&#39;, &#39;jupyterlab&#39;, &#39;kaggle&#39;, &#39;nteract&#39;, &#39;png&#39;, &#39;svg&#39;, &#39;zeppelin&#39;]) . from vega_datasets import data . We use the Gapminder health and income dataset . health_income = data(&#39;gapminder-health-income&#39;) health_income.head() . country income health population . 0 Afghanistan | 1925 | 57.63 | 32526562 | . 1 Albania | 10620 | 76.00 | 2896679 | . 2 Algeria | 13434 | 76.50 | 39666519 | . 3 Andorra | 46577 | 84.10 | 70473 | . 4 Angola | 7615 | 61.00 | 25021974 | . income_domain = [health_income[&#39;income&#39;].min(), health_income[&#39;income&#39;].max()] health_domain = [health_income[&#39;health&#39;].min(), health_income[&#39;health&#39;].max()] alt.Chart(health_income).mark_point().encode( alt.X(&#39;income:Q&#39;, scale=alt.Scale(domain=income_domain)), alt.Y(&#39;health:Q&#39;, scale=alt.Scale(domain=health_domain)), alt.Size(&#39;population:Q&#39;), alt.Tooltip(&#39;country:N&#39;) ).properties(height=600, width=800) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . The process: . Take the values&#39; difference from the smallest one; | Take the value range, that is, the difference between the largest and smallest values; | Divide the reduced values with the range. | $ text {scaled value} = frac{value - min} {max - min} $ . The first step ensures that the smallest value will become 0. Dividing the reduced values by the range &#39;compresses&#39; the values so the new maximum becomes 1. . quantitative_columns = [&#39;income&#39;, &#39;health&#39;, &#39;population&#39;] . The original minimum and maximum values . health_income.loc[health_income[quantitative_columns].idxmin(), :] . country income health population . 32 Central African Republic | 599 | 53.8 | 4900274 | . 93 Lesotho | 2598 | 48.5 | 2135022 | . 105 Marshall Islands | 3661 | 65.1 | 52993 | . minimums = health_income[quantitative_columns].min() minimums . income 599.0 health 48.5 population 52993.0 dtype: float64 . health_income.loc[health_income[quantitative_columns].idxmax(), :] . country income health population . 134 Qatar | 132877 | 82.0 | 2235355 | . 3 Andorra | 46577 | 84.1 | 70473 | . 35 China | 13334 | 76.9 | 1376048943 | . maximums = health_income[quantitative_columns].max() maximums . income 1.328770e+05 health 8.410000e+01 population 1.376049e+09 dtype: float64 . Difference of values from the column minimum . health_income[quantitative_columns] - minimums . income health population . 0 1326.0 | 9.13 | 32473569.0 | . 1 10021.0 | 27.50 | 2843686.0 | . 2 12835.0 | 28.00 | 39613526.0 | . 3 45978.0 | 35.60 | 17480.0 | . 4 7016.0 | 12.50 | 24968981.0 | . ... ... | ... | ... | . 182 5024.0 | 28.00 | 93394608.0 | . 183 3720.0 | 26.70 | 4615473.0 | . 184 3288.0 | 19.10 | 26779222.0 | . 185 3435.0 | 10.46 | 16158774.0 | . 186 1202.0 | 11.51 | 15549758.0 | . 187 rows × 3 columns . Value ranges: the difference between the maximum and the minimum . maximums - minimums . income 1.322780e+05 health 3.560000e+01 population 1.375996e+09 dtype: float64 . Let&#39;s normalize the dataset . def normalize_dataset(dataset, quantitative_columns): dataset = dataset.copy() minimums = dataset[quantitative_columns].min() maximums = dataset[quantitative_columns].max() dataset[quantitative_columns] = (dataset[quantitative_columns] - minimums) / (maximums - minimums) return dataset . normalized_health_income = normalize_dataset(health_income, quantitative_columns) normalized_health_income . country income health population . 0 Afghanistan | 0.010024 | 0.256461 | 0.023600 | . 1 Albania | 0.075757 | 0.772472 | 0.002067 | . 2 Algeria | 0.097030 | 0.786517 | 0.028789 | . 3 Andorra | 0.347586 | 1.000000 | 0.000013 | . 4 Angola | 0.053040 | 0.351124 | 0.018146 | . ... ... | ... | ... | ... | . 182 Vietnam | 0.037981 | 0.786517 | 0.067874 | . 183 West Bank and Gaza | 0.028123 | 0.750000 | 0.003354 | . 184 Yemen | 0.024857 | 0.536517 | 0.019462 | . 185 Zambia | 0.025968 | 0.293820 | 0.011743 | . 186 Zimbabwe | 0.009087 | 0.323315 | 0.011301 | . 187 rows × 4 columns . The new minimum and maximum values . normalized_health_income.loc[normalized_health_income[quantitative_columns].idxmin(), :] . country income health population . 32 Central African Republic | 0.000000 | 0.148876 | 0.003523 | . 93 Lesotho | 0.015112 | 0.000000 | 0.001513 | . 105 Marshall Islands | 0.023148 | 0.466292 | 0.000000 | . normalized_health_income.loc[normalized_health_income[quantitative_columns].idxmax(), :] . country income health population . 134 Qatar | 1.000000 | 0.941011 | 0.001586 | . 3 Andorra | 0.347586 | 1.000000 | 0.000013 | . 35 China | 0.096275 | 0.797753 | 1.000000 | . Plotting the normalized data, we got the same results, but with the income, health, and population scales all normalized to the [0, 1] range. . Maximum values . alt.Chart(normalized_health_income).mark_point().encode( alt.X(&#39;income:Q&#39;,), alt.Y(&#39;health:Q&#39;), alt.Size(&#39;population:Q&#39;), alt.Tooltip(&#39;country:N&#39;) ).properties(height=600, width=800) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html .",
            "url": "andrasnovoszath.com/2020/09/20/_2020-09-21-normalize-scale.html",
            "relUrl": "/2020/09/20/_2020-09-21-normalize-scale.html",
            "date": " • Sep 20, 2020"
        }
        
    
  
    
        ,"post8": {
            "title": "How to use Altair for data visualization in Python?",
            "content": "For the notebook I use the following packages. . 3.8.5 (default, Sep 4 2020, 07:30:14) [GCC 7.3.0] pandas: 1.1.0 altair: 3.2.0 . We load the &#39;flights&#39; example dataset . # collapse_show flights = &quot;https://vega.github.io/vega-datasets/data/flights-5k.json&quot; . . df_flights = pd.read_json(flights) origins = df_flights[&quot;origin&quot;].unique().tolist() destinations = df_flights[&quot;destination&quot;].unique().tolist() . # Origin locations print(&quot; t&quot;.join(origins)) . SAT SNA SJC SMF OKC PHX BHM MDW TUL MSY LAS BUF DTW HRL MCO RNO OAK JAX MCI SAN BNA STL FLL TPA HOU LAX BWI AUS ELP ONT PBI ABQ IND PDX DAL CLE MHT AMA SLC PVD SEA BOI ISP OMA LBB CRP RDU SDF BUR MAF LIT TUS BDL GEG SFO JAN IAH ALB CMH . # Destination locations print(&quot; t&quot;.join(destinations)) . HOU OAK SAN PHX RNO STL SDF OMA DAL SJC BWI MDW FLL SEA BHM PDX SLC BNA BOI TUS LAX ONT MCI CMH BDL LAS ISP TPA ABQ SAT MAF TUL ELP MCO SMF MHT MSY AUS PVD GEG BUR CRP JAN LIT SFO SNA OKC CLE IND HRL BUF JAX RDU AMA DTW PBI LBB ALB IAH . # Altair single-value selection selection = alt.selection_single( name=&quot;Select&quot;, fields=[&quot;origin&quot;, &quot;destination&quot;], bind={ &quot;origin&quot;: alt.binding_select(options=origins), &quot;destination&quot;: alt.binding_select(options=destinations), }, ) . # Scatter plot alt.Chart(df_flights).mark_circle().add_selection( selection ).encode( x=&#39;distance&#39;, y=&#39;delay&#39;, tooltip=&#39;date&#39;, opacity=alt.condition(selection, alt.value(.75), alt.value(.05)) ) # alt.Chart(movies).mark_circle().add_selection( # selection # ).encode( # x=&#39;Rotten Tomatoes Rating:Q&#39;, # y=&#39;IMDB Rating:Q&#39;, # tooltip=&#39;Title:N&#39;, # opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) # ) . NameError Traceback (most recent call last) &lt;ipython-input-2-54fe3fca6fea&gt; in &lt;module&gt; 1 # Scatter plot 2 -&gt; 3 alt.Chart(df_flights).mark_circle().add_selection( 4 selection 5 ).encode( NameError: name &#39;alt&#39; is not defined . Altair tutorial introduction . from vega_datasets import data . # hide_collapse # load more datasets population = data.population() jobs = data.jobs() countries = data.countries() budget = data.budget() unemployment_industries = data.unemployment_across_industries() employment = data.us_employment() . employment = employment.set_index(&#39;month&#39;).stack().reset_index().rename(columns={&#39;level_1&#39;: &#39;sector&#39;, 0: &#39;employment&#39;}) employment = employment[employment[&#39;sector&#39;] != &#39;nonfarm_change&#39;] . employment . month sector employment . 0 2006-01-01 | nonfarm | 135450.0 | . 1 2006-01-01 | private | 113603.0 | . 2 2006-01-01 | goods_producing | 22467.0 | . 3 2006-01-01 | service_providing | 112983.0 | . 4 2006-01-01 | private_service_providing | 91136.0 | . ... ... | ... | ... | . 2754 2015-12-01 | professional_and_business_services | 19892.0 | . 2755 2015-12-01 | education_and_health_services | 22318.0 | . 2756 2015-12-01 | leisure_and_hospitality | 15408.0 | . 2757 2015-12-01 | other_services | 5652.0 | . 2758 2015-12-01 | government | 22100.0 | . 2640 rows × 3 columns . employment.groupby(&#39;sector&#39;).mean().sort_values(&#39;employment&#39;) . employment . sector . utilities 553.744167 | . mining_and_logging 777.400000 | . information 2809.400000 | . transportation_and_warehousing 4469.073333 | . nondurable_goods 4667.816667 | . other_services 5460.333333 | . wholesale_trade 5751.100000 | . construction 6365.475000 | . durable_goods 7832.866667 | . financial_activities 7991.691667 | . manufacturing 12500.683333 | . leisure_and_hospitality 13731.416667 | . retail_trade 15066.603333 | . professional_and_business_services 17902.258333 | . goods_producing 19643.558333 | . education_and_health_services 20129.216667 | . government 22150.125000 | . trade_transportation_utilties 25840.566667 | . private_service_providing 93864.883333 | . private 113508.441667 | . service_providing 116015.008333 | . nonfarm 135658.566667 | .",
            "url": "andrasnovoszath.com/2020/09/20/_2020-09-21-my_altair_tutorial.html",
            "relUrl": "/2020/09/20/_2020-09-21-my_altair_tutorial.html",
            "date": " • Sep 20, 2020"
        }
        
    
  
    
        ,"post9": {
            "title": "Interaction",
            "content": "import pandas as pd import altair as alt . Datasets . We will visualize a variety of datasets from the vega-datasets collection: . A dataset of cars from the 1970s and early 1980s, | A dataset of movies, previously used in the Data Transformation notebook, | A dataset containing ten years of S&amp;P 500 (sp500) stock prices, | A dataset of technology company stocks, and | A dataset of flights, including departure time, distance, and arrival delay. | . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . Introducing Selections . Let&#39;s start with a basic selection: simply clicking a point to highlight it. Using the cars dataset, we&#39;ll start with a scatter plot of horsepower versus miles per gallon, with a color encoding for the number cylinders in the car engine. . In addition, we&#39;ll create a selection instance by calling alt.selection_single(), indicating we want a selection defined over a single value. By default, the selection uses a mouse click to determine the selected value. To register a selection with a chart, we must add it using the .add_selection() method. . Once our selection has been defined, we can use it as a parameter for conditional encodings, which apply a different encoding depending on whether a data record lies in or out of the selection. For example, consider the following code: . color=alt.condition(selection, &#39;Cylinders:O&#39;, alt.value(&#39;grey&#39;)) . This encoding definition states that data points contained within the selection should be colored according to the Cylinder field, while non-selected data points should use a default grey. An empty selection includes all data points, and so initially all points will be colored. . Try clicking different points in the chart below. What happens? (Click the background to clear the selection state and return to an &quot;empty&quot; selection.) . selection = alt.selection_single(); ( alt.Chart(cars).mark_circle().add_selection(selection) .encode( x=&#39;Horsepower:Q&#39;, y=&#39;Miles_per_Gallon:Q&#39;, color=alt.condition(selection, &#39;Cylinders:O&#39;, alt.value(&#39;grey&#39;)), opacity=alt.condition(selection, alt.value(0.8), alt.value(0.1)) ) ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Of course, highlighting individual data points one-at-a-time is not particularly exciting! As we&#39;ll see, however, single value selections provide a useful building block for more powerful interactions. Moreover, single value selections are just one of the three selection types provided by Altair: . selection_single - select a single discrete value, by default on click events. | selection_multi - select multiple discrete values. The first value is selected on mouse click and additional values toggled using shift-click. | selection_interval - select a continuous range of values, initiated by mouse drag. | . Let&#39;s compare each of these selection types side-by-side. To keep our code tidy we&#39;ll first define a function (plot) that generates a scatter plot specification just like the one above. We can pass a selection to the plot function to have it applied to the chart: . def plot(selection): return alt.Chart(cars).mark_circle().add_selection( selection ).encode( x=&#39;Horsepower:Q&#39;, y=&#39;Miles_per_Gallon:Q&#39;, color=alt.condition(selection, &#39;Cylinders:O&#39;, alt.value(&#39;grey&#39;)), opacity=alt.condition(selection, alt.value(0.8), alt.value(0.1)) ).properties( width=240, height=180 ) . Let&#39;s use our plot function to create three chart variants, one per selection type. . The first (single) chart replicates our earlier example. The second (multi) chart supports shift-click interactions to toggle inclusion of multiple points within the selection. The third (interval) chart generates a selection region (or brush) upon mouse drag. Once created, you can drag the brush around to select different points, or scroll when the cursor is inside the brush to scale (zoom) the brush size. . Try interacting with each of the charts below! . alt.hconcat( plot(alt.selection_single()).properties(title=&#39;Single (Click)&#39;), plot(alt.selection_multi()).properties(title=&#39;Multi (Shift-Click)&#39;), plot(alt.selection_interval()).properties(title=&#39;Interval (Drag)&#39;) ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . The examples above use default interactions (click, shift-click, drag) for each selection type. We can further customize the interactions by providing input event specifications using Vega event selector syntax. For example, we can modify our single and multi charts to trigger upon mouseover events instead of click events. . Hold down the shift key in the second chart to &quot;paint&quot; with data! . alt.hconcat( plot(alt.selection_single(on=&#39;mouseover&#39;)).properties(title=&#39;Single (Mouseover)&#39;), plot(alt.selection_multi(on=&#39;mouseover&#39;)).properties(title=&#39;Multi (Shift-Mouseover)&#39;) ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Now that we&#39;ve covered the basics of Altair selections, let&#39;s take a tour through the various interaction techniques they enable! . Dynamic Queries . Dynamic queries enables rapid, reversible exploration of data to isolate patterns of interest. As defined by Ahlberg, Williamson, &amp; Shneiderman, a dynamic query: . represents a query graphically, | provides visible limits on the query range, | provides a graphical representation of the data and query result, | gives immediate feedback of the result after every query adjustment, | and allows novice users to begin working with little training. | . A common approach is to manipulate query parameters using standard user interface widgets such as sliders, radio buttons, and drop-down menus. To generate dynamic query widgets, we can apply a selection&#39;s bind operation to one or more data fields we wish to query. . Let&#39;s build an interactive scatter plot that uses a dynamic query to filter the display. Given a scatter plot of movie ratings (from Rotten Tomates and IMDB), we can add a selection over the Major Genre field to enable interactive filtering by film genre. . To start, let&#39;s extract the unique (non-null) genres from the movies data: . df = pd.read_json(movies) # load movies data genres = df[&#39;Major Genre&#39;].unique() # get unique field values genres = list(filter(lambda d: d is not None, genres)) # filter out None values genres.sort() # sort alphabetically . For later use, let&#39;s also define a list of unique MPAA_Rating values: . mpaa = [&#39;G&#39;, &#39;PG&#39;, &#39;PG-13&#39;, &#39;R&#39;, &#39;NC-17&#39;, &#39;Not Rated&#39;] . Now let&#39;s create a single selection bound to a drop-down menu. . Use the dynamic query menu below to explore the data. How do ratings vary by genre? How would you revise the code to filter MPAA_Rating (G, PG, PG-13, etc.) instead of Major Genre? . selectGenre = alt.selection_single( name=&#39;Select&#39;, # name the selection &#39;Select&#39; fields=[&#39;Major Genre&#39;], # limit selection to the Major Genre field init={&#39;Major Genre&#39;: genres[0]}, # use first genre entry as initial value bind=alt.binding_select(options=genres) # bind to a menu of unique genre values ) alt.Chart(movies).mark_circle().add_selection( selectGenre ).encode( x=&#39;Rotten Tomatoes Rating:Q&#39;, y=&#39;IMDB Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selectGenre, alt.value(0.75), alt.value(0.05)) ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Our construction above leverages multiple aspects of selections: . We give the selection a name (&#39;Select&#39;). This name is not required, but allows us to influence the label text of the generated dynamic query menu. (What happens if you remove the name? Try it!) | We constrain the selection to a specific data field (Major Genre). Earlier when we used a single selection, the selection mapped to individual data points. By limiting the selection to a specific field, we can select all data points whose Major Genre field value matches the single selected value. | We initialize init=... the selection to a starting value. | We bind the selection to an interface widget, in this case a drop-down menu via binding_select. | As before, we then use a conditional encoding to control the opacity channel. | . Binding Selections to Multiple Inputs . One selection instance can be bound to multiple dynamic query widgets. Let&#39;s modify the example above to provide filters for both Major Genre and MPAA_Rating, using radio buttons instead of a menu. Our single selection is now defined over a single pair of genre and MPAA rating values . Look for surprising conjunctions of genre and rating. Are there any G or PG-rated horror films? . # single-value selection over [Major Genre, MPAA_Rating] pairs # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(movies).mark_circle().add_selection( selection ).encode( x=&#39;Rotten Tomatoes Rating:Q&#39;, y=&#39;IMDB Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Fun facts: The PG-13 rating didn&#39;t exist when the movies Jaws and Jaws 2 were released. The first film to receive a PG-13 rating was 1984&#39;s Red Dawn. . Using Visualizations as Dynamic Queries . Though standard interface widgets show the possible query parameter values, they do not visualize the distribution of those values. We might also wish to use richer interactions, such as multi-value or interval selections, rather than input widgets that select only a single value at a time. . To address these issues, we can author additional charts to both visualize data and support dynamic queries. Let&#39;s add a histogram of the count of films per year and use an interval selection to dynamically highlight films over selected time periods. . Interact with the year histogram to explore films from different time periods. Do you seen any evidence of sampling bias across the years? (How do year and critics&#39; ratings relate?) . The years range from 1930 to 2040! Are future films in pre-production, or are there &quot;off-by-one century&quot; errors? Also, depending on which time zone you&#39;re in, you may see a small bump in either 1969 or 1970. Why might that be? (See the end of the notebook for an explanation!) . brush = alt.selection_interval( encodings=[&#39;x&#39;] # limit selection to x-axis (year) values ) # dynamic query histogram years = alt.Chart(movies).mark_bar().add_selection( brush ).encode( alt.X(&#39;year(Release Date):T&#39;, title=&#39;Films by Release Year&#39;), alt.Y(&#39;count():Q&#39;, title=None) ).properties( width=650, height=50 ) # scatter plot, modify opacity based on selection ratings = alt.Chart(movies).mark_circle().encode( x=&#39;Rotten Tomatoes Rating:Q&#39;, y=&#39;IMDB Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(brush, alt.value(0.75), alt.value(0.05)) ).properties( width=650, height=400 ) alt.vconcat(years, ratings).properties(spacing=5) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . The example above provides dynamic queries using a linked selection between charts: . We create an interval selection (brush), and set encodings=[&#39;x&#39;] to limit the selection to the x-axis only, resulting in a one-dimensional selection interval. | We register brush with our histogram of films per year via .add_selection(brush). | We use brush in a conditional encoding to adjust the scatter plot opacity. | . This interaction technique of selecting elements in one chart and seeing linked highlights in one or more other charts is known as brushing &amp; linking. . Panning &amp; Zooming . The movie rating scatter plot is a bit cluttered in places, making it hard to examine points in denser regions. Using the interaction techniques of panning and zooming, we can inspect dense regions more closely. . Let&#39;s start by thinking about how we might express panning and zooming using Altair selections. What defines the &quot;viewport&quot; of a chart? Axis scale domains! . We can change the scale domains to modify the visualized range of data values. To do so interactively, we can bind an interval selection to scale domains with the code bind=&#39;scales&#39;. The result is that instead of an interval brush that we can drag and zoom, we instead can drag and zoom the entire plotting area! . In the chart below, click and drag to pan (translate) the view, or scroll to zoom (scale) the view. What can you discover about the precision of the provided rating values? . alt.Chart(movies).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;) ).encode( x=&#39;Rotten Tomatoes Rating:Q&#39;, y=alt.Y(&#39;IMDB Rating:Q&#39;, axis=alt.Axis(minExtent=30)), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release Date:N&#39;, &#39;IMDB Rating:Q&#39;, &#39;Rotten Tomatoes Rating:Q&#39;] ).properties( width=600, height=400 ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Zooming in, we can see that the rating values have limited precision! The Rotten Tomatoes ratings are integers, while the IMDB ratings are truncated to tenths. As a result, there is overplotting even when we zoom, with multiple movies sharing the same rating values. . Reading the code above, you may notice the code alt.Axis(minExtent=30) in the y encoding channel. The minExtent parameter ensures a minimum amount of space is reserved for axis ticks and labels. Why do this? When we pan and zoom, the axis labels may change and cause the axis title position to shift. By setting a minimum extent we can reduce distracting movements in the plot. Try changing the minExtent value, for example setting it to zero, and then zoom out to see what happens when longer axis labels enter the view. . Altair also includes a shorthand for adding panning and zooming to a plot. Instead of directly creating a selection, you can call .interactive() to have Altair automatically generate an interval selection bound to the chart&#39;s scales: . alt.Chart(movies).mark_circle().encode( x=&#39;Rotten Tomatoes Rating:Q&#39;, y=alt.Y(&#39;IMDB Rating:Q&#39;, axis=alt.Axis(minExtent=30)), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release Date:N&#39;, &#39;IMDB Rating:Q&#39;, &#39;Rotten Tomatoes Rating:Q&#39;] ).properties( width=600, height=400 ).interactive() . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . By default, scale bindings for selections include both the x and y encoding channels. What if we want to limit panning and zooming along a single dimension? We can invoke encodings=[&#39;x&#39;] to constrain the selection to the x channel only: . alt.Chart(movies).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( x=&#39;Rotten Tomatoes Rating:Q&#39;, y=alt.Y(&#39;IMDB Rating:Q&#39;, axis=alt.Axis(minExtent=30)), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release Date:N&#39;, &#39;IMDB Rating:Q&#39;, &#39;Rotten Tomatoes Rating:Q&#39;] ).properties( width=600, height=400 ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . When zooming along a single axis only, the shape of the visualized data can change, potentially affecting our perception of relationships in the data. Choosing an appropriate aspect ratio is an important visualization design concern! . Navigation: Overview + Detail . When panning and zooming, we directly adjust the &quot;viewport&quot; of a chart. The related navigation strategy of overview + detail instead uses an overview display to show all of the data, while supporting selections that pan and zoom a separate focus display. . Below we have two area charts showing a decade of price fluctuations for the S&amp;P 500 stock index. Initially both charts show the same data range. Click and drag in the bottom overview chart to update the focus display and examine specific time spans. . brush = alt.selection_interval(encodings=[&#39;x&#39;]); base = alt.Chart().mark_area().encode( alt.X(&#39;date:T&#39;, title=None), alt.Y(&#39;price:Q&#39;) ).properties( width=700 ) alt.vconcat( base.encode(alt.X(&#39;date:T&#39;, title=None, scale=alt.Scale(domain=brush))), base.add_selection(brush).properties(height=60), data=sp500 ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Unlike our earlier panning &amp; zooming case, here we don&#39;t want to bind a selection directly to the scales of a single interactive chart. Instead, we want to bind the selection to a scale domain in another chart. To do so, we update the x encoding channel for our focus chart, setting the scale domain property to reference our brush selection. If no interval is defined (the selection is empty), Altair ignores the brush and uses the underlying data to determine the domain. When a brush interval is created, Altair instead uses that as the scale domain for the focus chart. . Details on Demand . Once we spot points of interest within a visualization, we often want to know more about them. Details-on-demand refers to interactively querying for more information about selected values. Tooltips are one useful means of providing details on demand. However, tooltips typically only show information for one data point at a time. How might we show more? . The movie ratings scatterplot includes a number of potentially interesting outliers where the Rotten Tomatoes and IMDB ratings disagree. Let&#39;s create a plot that allows us to interactively select points and show their labels. . Mouse over points in the scatter plot below to see a highlight and title label. Shift-click points to make annotations persistent and view multiple labels at once. Which movies are loved by Rotten Tomatoes critics, but not the general audience on IMDB (or vice versa)? See if you can find possible errors, where two different movies with the same name were accidentally combined! . hover = alt.selection_single( on=&#39;mouseover&#39;, # select on mouseover nearest=True, # select nearest point to mouse cursor empty=&#39;none&#39; # empty selection should match nothing ) click = alt.selection_multi( empty=&#39;none&#39; # empty selection matches no points ) # scatter plot encodings shared by all marks plot = alt.Chart().mark_circle().encode( x=&#39;Rotten Tomatoes Rating:Q&#39;, y=&#39;IMDB Rating:Q&#39; ) # shared base for new layers base = plot.transform_filter( # logical OR is supported by Vega-Lite, nice syntax still needed for Altair {&#39;or&#39;: [hover, click]} # filter to points in either selection ) # layer scatter plot points, halo annotations, and title labels alt.layer( plot.add_selection(hover).add_selection(click), base.mark_point(size=100, stroke=&#39;firebrick&#39;, strokeWidth=1), base.mark_text(dx=4, dy=-8, align=&#39;right&#39;, stroke=&#39;white&#39;, strokeWidth=2).encode(text=&#39;Title:N&#39;), base.mark_text(dx=4, dy=-8, align=&#39;right&#39;).encode(text=&#39;Title:N&#39;), data=movies ).properties( width=600, height=450 ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . The example above adds three new layers to the scatter plot: a circular annotation, white text to provide a legible background, and black text showing a film title. In addition, this example uses two selections in tandem: . A single selection (hover) that includes nearest=True to automatically select the nearest data point as the mouse moves. | A multi selection (click) to create persistent selections via shift-click. | Both selections include the set empty=&#39;none&#39; to indicate that no points should be included if a selection is empty. These selections are then combined into a single filter predicate &mdash; the logical or of hover and click &mdash; to include points that reside in either selection. We use this predicate to filter the new layers to show annotations and labels for selected points only. . Using selections and layers, we can realize a number of different designs for details on demand! For example, here is a log-scaled time series of technology stock prices, annotated with a guideline and labels for the date nearest the mouse cursor: . # select a point for which to provide details-on-demand label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=700, height=400 ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Putting into action what we&#39;ve learned so far: can you modify the movie scatter plot above (the one with the dynamic query over years) to include a rule mark that shows the average IMDB (or Rotten Tomatoes) rating for the data contained within the year interval selection? . Brushing &amp; Linking, Revisited . Earlier in this notebook we saw an example of brushing &amp; linking: using a dynamic query histogram to highlight points in a movie rating scatter plot. Here, we&#39;ll visit some additional examples involving linked selections. . Returning to the cars dataset, we can use the repeat operator to build a scatter plot matrix (SPLOM) that shows associations between mileage, acceleration, and horsepower. We can define an interval selection and include it within our repeated scatter plot specification to enable linked selections among all the plots. . Click and drag in any of the plots below to perform brushing &amp; linking! . brush = alt.selection_interval( resolve=&#39;global&#39; # resolve all selections to a single global instance ) alt.Chart(cars).mark_circle().add_selection( brush ).encode( alt.X(alt.repeat(&#39;column&#39;), type=&#39;quantitative&#39;), alt.Y(alt.repeat(&#39;row&#39;), type=&#39;quantitative&#39;), color=alt.condition(brush, &#39;Cylinders:O&#39;, alt.value(&#39;grey&#39;)), opacity=alt.condition(brush, alt.value(0.8), alt.value(0.1)) ).properties( width=140, height=140 ).repeat( column=[&#39;Acceleration&#39;, &#39;Horsepower&#39;, &#39;Miles_per_Gallon&#39;], row=[&#39;Miles_per_Gallon&#39;, &#39;Horsepower&#39;, &#39;Acceleration&#39;] ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Note above the use of resolve=&#39;global&#39; on the interval selection. The default setting of &#39;global&#39; indicates that across all plots only one brush can be active at a time. However, in some cases we might want to define brushes in multiple plots and combine the results. If we use resolve=&#39;union&#39;, the selection will be the union of all brushes: if a point resides within any brush it will be selected. Alternatively, if we use resolve=&#39;intersect&#39;, the selection will consist of the intersection of all brushes: only points that reside within all brushes will be selected. . Try setting the resolve parameter to &#39;union&#39; and &#39;intersect&#39; and see how it changes the resulting selection logic. . Cross-Filtering . The brushing &amp; linking examples we&#39;ve looked at all use conditional encodings, for example to change opacity values in response to a selection. Another option is to use a selection defined in one view to filter the content of another view. . Let&#39;s build a collection of histograms for the flights dataset: arrival delay (how early or late a flight arrives, in minutes), distance flown (in miles), and time of departure (hour of the day). We&#39;ll use the repeat operator to create the histograms, and add an interval selection for the x axis with brushes resolved via intersection. . In particular, each histogram will consist of two layers: a gray background layer and a blue foreground layer, with the foreground layer filtered by our intersection of brush selections. The result is a cross-filtering interaction across the three charts! . Drag out brush intervals in the charts below. As you select flights with longer or shorter arrival delays, how do the distance and time distributions respond? . brush = alt.selection_interval( encodings=[&#39;x&#39;], resolve=&#39;intersect&#39; ); hist = alt.Chart().mark_bar().encode( alt.X(alt.repeat(&#39;row&#39;), type=&#39;quantitative&#39;, bin=alt.Bin(maxbins=100, minstep=1), # up to 100 bins axis=alt.Axis(format=&#39;d&#39;, titleAnchor=&#39;start&#39;) # integer format, left-aligned title ), alt.Y(&#39;count():Q&#39;, title=None) # no y-axis title ) alt.layer( hist.add_selection(brush).encode(color=alt.value(&#39;lightgrey&#39;)), hist.transform_filter(brush) ).properties( width=900, height=100 ).repeat( row=[&#39;delay&#39;, &#39;distance&#39;, &#39;time&#39;], data=flights ).transform_calculate( delay=&#39;datum.delay &lt; 180 ? datum.delay : 180&#39;, # clamp delays &gt; 3 hours time=&#39;hours(datum.date) + minutes(datum.date) / 60&#39; # fractional hours ).configure_view( stroke=&#39;transparent&#39; # no outline ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . By cross-filtering you can observe that delayed flights are more likely to depart at later hours. This phenomenon is familiar to frequent fliers: a delay can propagate through the day, affecting subsequent travel by that plane. For the best odds of an on-time arrival, book an early flight! . The combination of multiple views and interactive selections can enable valuable forms of multi-dimensional reasoning, turning even basic histograms into powerful input devices for asking questions of a dataset! . Summary . For more information about the supported interaction options in Altair, please consult the Altair interactive selection documentation. For details about customizing event handlers, for example to compose multiple interaction techniques or support touch-based input on mobile devices, see the Vega-Lite selection documentation. . Interested in learning more? . The selection abstraction was introduced in the paper Vega-Lite: A Grammar of Interactive Graphics, by Satyanarayan, Moritz, Wongsuphasawat, &amp; Heer. | The PRIM-9 system (for projection, rotation, isolation, and masking in up to 9 dimensions) is one of the earliest interactive visualization tools, built in the early 1970s by Fisherkeller, Tukey, &amp; Friedman. A retro demo video survives! | The concept of brushing &amp; linking was crystallized by Becker, Cleveland, &amp; Wilks in their 1987 article Dynamic Graphics for Data Analysis. | For a comprehensive summary of interaction techniques for visualization, see Interactive Dynamics for Visual Analysis by Heer &amp; Shneiderman. | Finally, for a treatise on what makes interaction effective, read the classic Direct Manipulation Interfaces paper by Hutchins, Hollan, &amp; Norman. | . Appendix: On The Representation of Time . Earlier we observed a small bump in the number of movies in either 1969 and 1970. Where does that bump come from? And why 1969 or 1970? The answer stems from a combination of missing data and how your computer represents time. . Internally, dates and times are represented relative to the UNIX epoch, in which time &quot;zero&quot; corresponds to the stroke of midnight on January 1, 1970 in UTC time, which runs along the prime meridian. It turns out there are a few movies with missing (null) release dates. Those null values get interpreted as time 0, and thus map to January 1, 1970 in UTC time. If you live in the Americas &ndash; and thus in &quot;earlier&quot; time zones &ndash; this precise point in time corresponds to an earlier hour on December 31, 1969 in your local time zone. On the other hand, if you live near or east of the prime meridian, the date in your local time zone will be January 1, 1970. . The takeaway? Always be skeptical of your data, and be mindful that how data is represented (whether as date times, or floating point numbers, or latitudes and longitudes, etc.) can sometimes lead to artifacts that impact analysis! .",
            "url": "andrasnovoszath.com/2020/09/20/_2020-09-21-altair_interaction.html",
            "relUrl": "/2020/09/20/_2020-09-21-altair_interaction.html",
            "date": " • Sep 20, 2020"
        }
        
    
  
    
        ,"post10": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # Title &gt; Awesome summary - toc:true- branch: master- badges: true- comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . #collapse-hide import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . #collapse-show cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # single-value selection over [Major Genre, MPAA_Rating] pairs # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(movies).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Example 2: Tooltips . alt.Chart(movies).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=alt.Y(&#39;IMDB_Rating:Q&#39;, axis=alt.Axis(minExtent=30)), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=600, height=400 ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Example 3: More Tooltips . # select a point for which to provide details-on-demand label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=700, height=400 ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Data Tables . You can display tables per the usual way in your blog: . movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; df = pd.read_json(movies) # display table with pandas df[[&#39;Title&#39;, &#39;Worldwide Gross&#39;, &#39;Production Budget&#39;, &#39;Distributor&#39;, &#39;MPAA Rating&#39;, &#39;IMDB Rating&#39;, &#39;Rotten Tomatoes Rating&#39;]].head() . Title Worldwide Gross Production Budget Distributor MPAA Rating IMDB Rating Rotten Tomatoes Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "andrasnovoszath.com/jupyter/2020/09/20/_2020-02-20-test.html",
            "relUrl": "/jupyter/2020/09/20/_2020-02-20-test.html",
            "date": " • Sep 20, 2020"
        }
        
    
  
    
        ,"post11": {
            "title": "The sum of stock trading",
            "content": "I thought further about my previous position on whether stock trading is a zero-sum game. Now I see a bigger space for it not to be one. . Trading growth stocks . The situation I am thinking about is an argument I found during my google search. . Very simply, one buys a stock at one point in time and sells it to someone else in another. . Let’s take the ‘classical’ position on stocks and consider it merely an investment asset. In this case, we can argue that stock buyers lent money to a company in exchange for a part of its profits. They sell the stocks when it wants to get their money back, say for their retirement. . Here the value comes for the original owner in that the price will be higher when they sell. . This is the same hope the sellers have for the time when they want to realize their investment. That is, when the original buyers sell the stock, the new buyers can get a ‘fair’ price if, in that given time, the stock is still promising some price growth. . This seems more positive-sum for me. However, this view works if we strip away the ‘speculative’ (?), arbitrage-seeking trading aspect of security trading. In this view, stock trading seems to resemble the trade of a good tool one does not need anymore. . Remaining questions . There are, of course, a number of issues still unclear for me. . The first is whether ‘speculation’ or ‘arbitrage seeking’ inevitably leads to a zero-sum outcome? Also, can we separate ‘straightforward’ investment from these activities? . The next is about the buying price: when is the price too high/low? . The buyer could always want to ask for a higher price. Aren’t selling a stock at a too high price basically strips away the seller’s possible gains? . On the other hand, one might argue that, if the price reflects the market price, there is less space for unfairness (or at least not directly between the two parties). . Third, there is the question of whether a company can grow infinitely or trading stock is always based on this false promise. . Finally, how do we calculate the outcomes when the ‘gain’, in big part, comes from luck and decisions made years before their realization. .",
            "url": "andrasnovoszath.com/stock%20trading/zero-sum/finance/valuation/2020/09/19/stock-trading-sum.html",
            "relUrl": "/stock%20trading/zero-sum/finance/valuation/2020/09/19/stock-trading-sum.html",
            "date": " • Sep 19, 2020"
        }
        
    
  
    
        ,"post12": {
            "title": "How to build up a writing habit?",
            "content": "If you tend to analyze a lot but want to build up a consistent writing habit, the following tips might help. . Take notes . Have a notepad or a very light-weight text editor/app that you can open at any time and dump your ideas effortlessly. . Find out what interests you . Review your notes, todo lists, emails, past writing, or any other traces about yourself. Look for frequent themes about which you feel strongly and, even better, about which you developed some depth in skill or knowledge. . Prioritize your themes . Take these themes and group or merge the closely related ones. Then, prioritize them based on their importance. . When you have them ranked, drop the last 80% and focus on the remaining 20%. If you have too too many themes remained (e.g., more than 10), drop even more. . Brainstorm post ideas . For each remaining theme, write as many post ideas as possible, but a minimum of ten. Do not bother with how good or viable they are. The important thing is to have a high number of them. . Rotate your themes . Now you have a list of topics organized under themes. Outline a rotating schedule where you order the themes into a sequence, so, in each day, you write about a topic belonging to the next theme. . Write . Each day, you take the topics belonging under that day’s theme and pick one randomly. Write about it impatiently, badly, and experimentally for a minimum 5 minutes. . When you find that you could write about multiple things but you do not know which to pick, pick the first one and move the second into your ideas under the same theme. . When you run out of time, you will find yourself wanting to write more about something. Move it as a new topic under the same theme. . Publish . Publish the writing to somewhere, where nobody sees is. For example, create an account on Medium or any blogging platform under some alias. . Repeat . When you arrive at the end of the sequence, start again. If you could fill out all your 5 minutes for each day for a week, add an extra 5 minutes for your writing time. .",
            "url": "andrasnovoszath.com/writing/habit/2020/09/18/writing-habit.html",
            "relUrl": "/writing/habit/2020/09/18/writing-habit.html",
            "date": " • Sep 18, 2020"
        }
        
    
  
    
        ,"post13": {
            "title": "Is finance a zero-sum activity?",
            "content": "I recently thought about finance and whether it is a purely zero-sum game or has some value-add to it. I would like to know this to see if it is worthy of support either as a personal wealth source or as a social institution. . I did not have time to read academic papers, so I simply did a google search (1-2 hours) and reviewed the top results. . What I found . Just based on this short research, I barely found any substantial arguments against the zero-sum claim. . What counterarguments I found were acknowledged that some forms, like forex or short-term trading, are zero-sum. They argued that, compared to the former types, ‘real’ stock trading can bring about benefits for both parties. Most of these were conflating terminology and concepts (like ‘luck’, or ‘value growth’). . There are probably more substantial arguments in academic literature. Also, probably, there is the additional question of the social usefulness of financial markets for overall capital allocation, but that’s a separate thing. . How I see it now . Of course, as I started to dive into the topic, I quickly realized that is is a bit more complex than I thought. . So let’s break up the question to the following cases: . Pure commercial relationship | Trading of goods | Finance | . Pure commercial transaction . When two people get into a commercial relationship, one is a ‘seller’, and the other is a ‘buyer’. Regarding the price, they have opposite aims. One’s income is another’s cost. . So, in this sense, every commercial transaction is zero-sum. . Trade of ‘comparatively advantageous’ goods . When the seller gives away something they cannot use, but the buyer can, the exchange might benefit both. There is still the issue of the price for which they exchange the good, but the buyer’s benefit from possessing the good might surpass its price. . So, here we can imagine a non-zero-sum relationship. . Finance . Most of the people who trade and invest mostly want to get the most payoff for their buck. So this primarily seems zero-sum. . The mutual benefit might come about when their relationship to their asset is more complex than just trying to get the highest price difference. . Conclusion . Again, I can see that I could think and write about this topic for a long time. Some ideas . How do we measure and compare ‘comparatively advantages’? | What are examples of not purely ‘buy low, sell high’ uses of finance? | How to measure the utility ‘ratio’ between price gain/loss and usability of the result of a buy event? | Is the social benefit of efficient capital distribution via financial markets a fluke, or has empirical evidence behind it? | Can we replace financial markets with an AI and delegate human creativity to more productive things? | .",
            "url": "andrasnovoszath.com/finance/zero-sum/valuation/2020/09/17/finance-zero-sum.html",
            "relUrl": "/finance/zero-sum/valuation/2020/09/17/finance-zero-sum.html",
            "date": " • Sep 17, 2020"
        }
        
    
  
    
        ,"post14": {
            "title": "The specific you",
            "content": "When you are thinking about what business area to pursue, it is useful to focus on your specific situation and circumstance. . Why is it useful to find a specialization? . When you do not look at your own specificities, you basically do not use knowledge and skills that others could use but cannot. . You have your history, your dis/abilities, your interests, and your own conceptual framing. Most of it might be useless, especially regarding all the people in the world. . However, there are a few problems which maybe you are the only one who can solve it. . This is not about ‘finding your passion’ but rather to find out your skills, knowledge, approach, etc. These are actually quite tangible. . How to know your specificities? . To see yourself better, write down your characteristics in as many dimensions as possible. . Here are some dimensions which you can look for: . Knowledge, | Skills, | Experience, | Interest. | . One thing you can do is to create a spreadsheet and write as many of these things as possible. Then, value them on a scale (e.g., 1-5) showing how specific these traits and dimensions are to you, especially compared to others. .",
            "url": "andrasnovoszath.com/self-knowledge/specialization/2020/09/16/specific-you.html",
            "relUrl": "/self-knowledge/specialization/2020/09/16/specific-you.html",
            "date": " • Sep 16, 2020"
        }
        
    
  
    
        ,"post15": {
            "title": "Valuation technology experimentation",
            "content": "It might be useful and promising to experiment with technologies of valuation. . How does valuation happen now, and how does technology play a role in it? . Current technologies of valuation are in place because of different reasons. However, implementers rarely take into account the way the given technology plays a role in valuing things. . Examples of the use of technology in valuation and some trends . Money is arguably the most prominent example. Probably this is not independent of that most of us still do not really understand all its effects. . Other examples are in accountancy, trade, work management, economic metrics, environmental management. . An obvious note is that, of course, other, not strictly technological components, like language, moral values, physical factors, etc., also have critial roles. . Think about and experiment with different technologies to generate new valuation situations . Accordingly, it might be beneficial to try out technologies with explicit valuation functions in mind. . For the most part, and especially in early stages, this is concept-driven (i.e., we are looking for a particular effect to emerge). However, an uncertain but promising benefit would be discovering ‘unthought’ features due to things’ specific and idiosyncratic character. . The process of valuation technology experiments and its main challenges . Most of the time, we cannot implement large scale infrastructures for the sake of experimentation. . Instead, we can try other paths: . Implementation of a small-scale but very focused version | Scenario building | Simulation | Game development | The empirical analysis of similar processes | The empirical analysis of current technologies’ edge cases | Speculation | Incremental implementation | . Current action possibilities and possible future directions . As, currently, I this all is very high level and conceptual, and I am also mostly interested in discovery activities: . Collecting ideas | Conceptual exploration of background ideas | Case study analysis | Code experimentations | . In the future, I might be able to focus it down and branch out toward more serious development work. .",
            "url": "andrasnovoszath.com/technology/valuation/experimentation/2020/09/15/technnology_valuation_experimentation.html",
            "relUrl": "/technology/valuation/experimentation/2020/09/15/technnology_valuation_experimentation.html",
            "date": " • Sep 15, 2020"
        }
        
    
  
    
        ,"post16": {
            "title": "Note-taking obsessions",
            "content": "I have an obsession with the process of note-taking. . I often write down my ideas in the form of notes or tasks. I do this through multiple channels. Then I spend a considerable amount of time organizing them. . One common frustration with organizing notes is that I can do this only along one hierarchical dimension. . Perhaps one reason I like to code is that you can implement hierarchies along multiple dimensions more easily, although not always. . Because of the single hierarchy, some notes tend to become forgotten as I put them in some deep end part of a category branch. This then requires me to constantly re- and review my notes and to recategorize and reorganize them. . I have looked into multiple note-taking software, but there is not really a perfect solution for this. . One thing I found helpful is to require only a single function from a particular tool. So, for instance, I would use one particular tool or process for note-taking, then another for categorization, and perhaps a further one for review or note management. . This, however, needs that the different tools speak to each other relatively well. Ready-made solutions often do not allow it, so I found myself moving toward text-based tools. However, you need to utilize some basic scripting to make them work. .",
            "url": "andrasnovoszath.com/note-taking/2020/09/14/note-taking-obsessions.html",
            "relUrl": "/note-taking/2020/09/14/note-taking-obsessions.html",
            "date": " • Sep 14, 2020"
        }
        
    
  
    
        ,"post17": {
            "title": "How to use Altair for data visualization in Python?",
            "content": "For the notebook I use the following packages. . 3.8.5 (default, Aug 5 2020, 08:36:46) [GCC 7.3.0] pandas: 1.1.0 altair: 3.2.0 . We load the &#39;flights&#39; example dataset . # collapse_show flights = &quot;https://vega.github.io/vega-datasets/data/flights-5k.json&quot; . . df_flights = pd.read_json(flights) origins = df_flights[&quot;origin&quot;].unique().tolist() destinations = df_flights[&quot;destination&quot;].unique().tolist() . # Origin locations print(&quot; t&quot;.join(origins)) . SAT SNA SJC SMF OKC PHX BHM MDW TUL MSY LAS BUF DTW HRL MCO RNO OAK JAX MCI SAN BNA STL FLL TPA HOU LAX BWI AUS ELP ONT PBI ABQ IND PDX DAL CLE MHT AMA SLC PVD SEA BOI ISP OMA LBB CRP RDU SDF BUR MAF LIT TUS BDL GEG SFO JAN IAH ALB CMH . # Destination locations print(&quot; t&quot;.join(destinations)) . HOU OAK SAN PHX RNO STL SDF OMA DAL SJC BWI MDW FLL SEA BHM PDX SLC BNA BOI TUS LAX ONT MCI CMH BDL LAS ISP TPA ABQ SAT MAF TUL ELP MCO SMF MHT MSY AUS PVD GEG BUR CRP JAN LIT SFO SNA OKC CLE IND HRL BUF JAX RDU AMA DTW PBI LBB ALB IAH . # Altair single-value selection selection = alt.selection_single( name=&quot;Select&quot;, fields=[&quot;origin&quot;, &quot;destination&quot;], bind={ &quot;origin&quot;: alt.binding_select(options=origins), &quot;destination&quot;: alt.binding_select(options=destinations), }, ) . # Scatter plot alt.Chart(df_flights).mark_circle().add_selection( selection ).encode( x=&#39;distance&#39;, y=&#39;delay&#39;, tooltip=&#39;date&#39;, opacity=alt.condition(selection, alt.value(.75), alt.value(.05)) ) # alt.Chart(movies).mark_circle().add_selection( # selection # ).encode( # x=&#39;Rotten Tomatoes Rating:Q&#39;, # y=&#39;IMDB Rating:Q&#39;, # tooltip=&#39;Title:N&#39;, # opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) # ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Altair tutorial introduction . from vega_datasets import data . # hide_collapse # load more datasets population = data.population() jobs = data.jobs() countries = data.countries() budget = data.budget() unemployment_industries = data.unemployment_across_industries() employment = data.us_employment() . employment = employment.set_index(&#39;month&#39;).stack().reset_index().rename(columns={&#39;level_1&#39;: &#39;sector&#39;, 0: &#39;employment&#39;}) employment = employment[employment[&#39;sector&#39;] != &#39;nonfarm_change&#39;] . employment . month sector employment . 0 2006-01-01 | nonfarm | 135450.0 | . 1 2006-01-01 | private | 113603.0 | . 2 2006-01-01 | goods_producing | 22467.0 | . 3 2006-01-01 | service_providing | 112983.0 | . 4 2006-01-01 | private_service_providing | 91136.0 | . ... ... | ... | ... | . 2754 2015-12-01 | professional_and_business_services | 19892.0 | . 2755 2015-12-01 | education_and_health_services | 22318.0 | . 2756 2015-12-01 | leisure_and_hospitality | 15408.0 | . 2757 2015-12-01 | other_services | 5652.0 | . 2758 2015-12-01 | government | 22100.0 | . 2640 rows × 3 columns . employment.groupby(&#39;sector&#39;).mean().sort_values(&#39;employment&#39;) . employment . sector . utilities 553.744167 | . mining_and_logging 777.400000 | . information 2809.400000 | . transportation_and_warehousing 4469.073333 | . nondurable_goods 4667.816667 | . other_services 5460.333333 | . wholesale_trade 5751.100000 | . construction 6365.475000 | . durable_goods 7832.866667 | . financial_activities 7991.691667 | . manufacturing 12500.683333 | . leisure_and_hospitality 13731.416667 | . retail_trade 15066.603333 | . professional_and_business_services 17902.258333 | . goods_producing 19643.558333 | . education_and_health_services 20129.216667 | . government 22150.125000 | . trade_transportation_utilties 25840.566667 | . private_service_providing 93864.883333 | . private 113508.441667 | . service_providing 116015.008333 | . nonfarm 135658.566667 | . employment_chart.mark_point() . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . employment_chart.mark_point().encode( x=&#39;month:T&#39;, y=&#39;employment_number:Q&#39; ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html .",
            "url": "andrasnovoszath.com/2020/08/20/my_altair_tutorial.html",
            "relUrl": "/2020/08/20/my_altair_tutorial.html",
            "date": " • Aug 20, 2020"
        }
        
    
  
    
        ,"post18": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # Title &gt; Awesome summary - toc:true- branch: master- badges: true- comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . #collapse-hide import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . #collapse-show cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # single-value selection over [Major Genre, MPAA_Rating] pairs # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(movies).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Example 2: Tooltips . alt.Chart(movies).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=alt.Y(&#39;IMDB_Rating:Q&#39;, axis=alt.Axis(minExtent=30)), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=600, height=400 ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Example 3: More Tooltips . # select a point for which to provide details-on-demand label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=700, height=400 ) . &lt;VegaLite 3 object&gt; If you see this message, it means the renderer has not been properly enabled for the frontend that you are using. For more information, see https://altair-viz.github.io/user_guide/troubleshooting.html . Data Tables . You can display tables per the usual way in your blog: . movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; df = pd.read_json(movies) # display table with pandas df[[&#39;Title&#39;, &#39;Worldwide Gross&#39;, &#39;Production Budget&#39;, &#39;Distributor&#39;, &#39;MPAA Rating&#39;, &#39;IMDB Rating&#39;, &#39;Rotten Tomatoes Rating&#39;]].head() . Title Worldwide Gross Production Budget Distributor MPAA Rating IMDB Rating Rotten Tomatoes Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "andrasnovoszath.com/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About",
          "content": "Online mental dump to put things out. Currently, I practice writing posts within 30 minutes. Still getting there… .",
          "url": "andrasnovoszath.com/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  

}